;; -*- mode: org; mode: logos-focus; -*-
:DOC-CONFIG:
#+property: header-args:emacs-lisp yes :comments no
#+startup: fold
:END:

#+title: Config
#+author: C√©dric Da Fonseca

* Level 1: Hangar ¬∑ /Introduction/

#+begin_quote
    Welcome to Doom, soldier. Now shut up and start +fighting+ coding because
    there's no time to waste!
#+end_quote

Welcome again! This is my personal Emacs configuration for the [[https://github.com/doomemacs/doomemacs][Doom Emacs]]
framework. In this ~config.org~ file lies most of my Emacs config. This is a
literate configuration, meaning the code that I stole from more competent
persons than myself will be generated to a nice Emacs config.

Why literate? Well, this allows me to have a nicely organized configuration with
lots of comments, which helps to give a false sense of order and quality.

Oh yeah, I almost forgot. The mandatory _disclaimer_:

If, by any chance, someone other than me stumble across this repository. *BEWARE*.
+ I mostly don't know what I am doing.
+ I don't understand ~emacs lisp~ very well, nor any intricacies of Emacs, such as load
  order and so on.
+ I might be doing stuff incredibly wrong, which might cause you to experience:
  /itching/, /headache/, /internal bleeding/, /raise your taxes/ and /kill your cat‚Ä¶/ to
  name a few. So again, *BEWARE*.

** Before we start

What better way to kick off this configuration than putting a line of code that
I have no idea what it does? Apparently it helps things run faster, me like
fast.

#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src

** How is this config organized?

Well, here's a good question. I didn't really think this through‚Ä¶

The general idea is to organize the packages' configurations in their own
subheading (see [[* Level 5: Phobos Lab ¬∑ /Packages/][Level 5]]).

Also if ~Doom~ already configures a package in a module, we extend that package
configuration in a subheading that represents the module it originates from
(it's in [[* Level 4: Command Control ¬∑ /Doom, but it's _my_ personal hell/][Level 4]]).

In [[* Level 6: Central Processing ¬∑ /Lang stuff/][Level 6]], I put language specific bits of configuration or helpful functions.

** Inspirations

Here's a non exhaustive list of config that helped me write this one. Thanks to
the authors üôè.

- [[https://github.com/abougouffa/dotfiles/blob/main/dot_doom.d/config.org][Abdelhak Bougouffa's config]]
- [[https://github.com/gtrunsec/nixos-flk/blob/main/users/dotfiles/doom-emacs/config.org][GTrunkSec's config]]
- [[https://ruivieira.dev/doom-emacs.html][Rui Vieira's config]]
- [[https://tecosaur.github.io/emacs-config/][Tecosaur's config]]
- [[https://git.sr.ht/~gagbo/doom-config/tree][Gagbo's config]]
- [[https://github.com/protesilaos/dotfiles/tree/master/emacs/.emacs.d][Prot's config]]
- [[https://github.com/hlissner/.doom.d][Hlissner's config]]
- [[https://github.com/SophieBosio/.emacs.d][Sophie Bosio's config]]
- [[https://github.com/rougier?tab=repositories&type=source][Nicolas Rougier's everything]]

  -----

* Level 2: Nuclear Plant ¬∑ /Let's get personal/

Please, allow me to introduce myself.

#+begin_src emacs-lisp
(setq user-full-name "C√©dric Da Fonseca"
      user-mail-address "captain.spof@gmail.com")
#+end_src

-----

* Level 3: Toxin Refinery ¬∑ /Defaults be bad/

This is the customary ¬´ /browsing through the game settings to change the default
parameters‚Ä¶/ ¬ª

** Optimisations

I found these settings somewhere, they're supposed to help with ¬´ /performance/ ¬ª,
so it must be good, right?

#+begin_src emacs-lisp :tangle packages.el
(package! gcmh) ;; https://github.com/emacsmirror/gcmh
#+end_src

#+begin_src emacs-lisp
(setq gc-cons-percentage 0.6
      read-process-output-max (* 1024 1024)) ;; 1mb

(use-package! gcmh
  :config
  (setq gcmh-idle-delay 5
        gcmh-high-cons-threshold (* 100 1024 1024))  ; 100mb
  (gcmh-mode 1))
#+end_src

** Personal =localleader= ¬∑ I am the captain, now

The =leader= and =localleader= keys are great, but I want my own, this way, I am
sure my key bindings won't interfere with anythings. I chose =SPC √ß=, but I might
change it to something else, maybe a dedicated key on my keyboard‚Ä¶

#+begin_src emacs-lisp
(defvar daf/localleader-key "SPC √ß"
  "The localleader prefix key, for major-mode specific commands.")
#+end_src

** There's no escaping ~evil~

Disabling ~evil-escape~, there's no escaping, I tried.

#+begin_src emacs-lisp :tangle packages.el
(package! evil-escape :disable t)
#+end_src

** Default Shell

To make ~fish~ happy, I guess.

#+begin_src emacs-lisp
(setq shell-file-name (executable-find "bash"))
(setq-default vterm-shell (executable-find "fish"))
(setq-default explicit-shell-file-name (executable-find "fish"))
#+end_src

Automatically kill sub-process on exit.

#+begin_src emacs-lisp
(setq confirm-kill-processes nil)
#+end_src

** Unclutter ~which-key~ menus

~which-key~ could be a little tad bit quicker to show up.

#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5)
#+end_src

I also think that having ~evil-~ appear in so many popups is a bit too verbose,
let‚Äôs change that. (credit's due to Tecosaur)

#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "Û∞á¥-\\1"))
   '(("" . "\\`+?evilem--?motion-\\(.*\\)")     . (nil . "Û∞±Ø-\\1"))))
#+end_src

** ~Dired~ when switching project

When switching to project, I'd rather have ~dired~ open to the project's root,
rather than the default ~find-file~ action.

#+begin_src emacs-lisp
(setq +workspaces-switch-project-function #'dired)
#+end_src

** Relocate bookmarks and projects files

Me dumb, when Emacs broky, me ~rm -rf emacs/.local~. This lead to losing some
useful stuff, like bookmarks and ~projectile~'s known projects, let's put them
elsewhere.

#+begin_src emacs-lisp
(setq bookmark-default-file (expand-file-name "local/bookmarks" doom-user-dir)
      projectile-known-projects-file (expand-file-name "local/projectile.projects" doom-user-dir))
#+end_src

There are also some projects and bookmarks I want as a base. Then I'll locally
add projet and bookmark (but they _should not_ be tracked by git).

#+begin_src lisp-data :tangle (if (not (file-exists-p "./local/projectile.projects")) "./local/projectile.projects" "")
("~/.config/doom/" "~/.config/dafos/")
#+end_src

And the bookmarks (=SPC RET=).

#+begin_src lisp-data :tangle (if (not (file-exists-p "./local/bookmarks")) "./local/bookmarks" "")
;;;; Emacs Bookmark Format Version 1;;;; -*- coding: utf-8-emacs; mode: lisp-data -*-
;;; This format is meant to be slightly human-readable;
;;; nevertheless, you probably don't want to edit it.
;;; -*- End Of Bookmark File Format Version Stamp -*-
(("Root ¬∑ /" (filename . "/"))
 ("Tmp ¬∑ /tmp" (filename . "/tmp/"))
 ("Home ¬∑ ~/" (filename . "~/"))
 ("config ¬∑ ~/.config" (filename . "~/.config/"))
 ("dafos ¬∑ ~/.config/dafos" (filename . "~/.config/dafos/"))
 ("doom ¬∑ ~/.config/doom" (filename . "~/.config/doom/"))
 ("Downloads ¬∑ ~/Downloads" (filename . "~/Downloads/"))
 ("Projects ¬∑ ~/Projects" (filename . "~/Projects/"))
 ("Pictures ¬∑ ~/Pictures" (filename . "~/Pictures/"))
 ("Sync ¬∑ ~/Sync" (filename . "~/Sync/"))
 ("Books ¬∑ ~/Sync/Books" (filename . "~/Sync/Books/"))
 ("Repos ¬∑ ~/Repositories" (filename . "~/Repositories/")))
#+end_src

** Can your repeat please?

I don't remember where I stole this nugget, but it allows to define repeat keys!
Super handy.

#+begin_src emacs-lisp
;;;###autoload
(defmacro daf/repeat-map! (map-name keys-alist &optional docstring)
  "A helper macro to create keymaps for repeatable actions.

MAP-NAME is the variable name for the sparse keymap created, and KEYS-ALIST, is
an association list of functions to keys, where each function is called after
the associated key is pressed after the repeatable action is triggered."
  `(defvar ,map-name
     (let ((map (make-sparse-keymap)))
       (dolist (cmd ,keys-alist)
         (define-key map (cdr cmd) (car cmd))
         (put (car cmd) 'repeat-map ',map-name))
       map)
     ,docstring))

(add-hook 'after-init-hook 'repeat-mode)
#+end_src

** Margin & Smooth scrolling

I often use =zt=, =zz= and =zb= to scroll through my window, this help to keep a tiny
bit of context above and bellow the current line.

#+begin_src emacs-lisp
(setq-default scroll-margin 3)
#+end_src

Emacs 29 introduced pixel scrolling. Let's make its V1 single threaded engine
roar!

#+begin_src emacs-lisp
(pixel-scroll-precision-mode 1)
(setq mouse-wheel-tilt-scroll t)

(defun filter-mwheel-always-coalesce (orig &rest args)
  "A filter function suitable for :around advices that ensures only
   coalesced scroll events reach the advised function."
  (if mwheel-coalesce-scroll-events
      (apply orig args)
    (setq mwheel-coalesce-scroll-events t)))

(defun filter-mwheel-never-coalesce (orig &rest args)
  "A filter function suitable for :around advices that ensures only
   non-coalesced scroll events reach the advised function."
  (if mwheel-coalesce-scroll-events
      (setq mwheel-coalesce-scroll-events nil)
    (apply orig args)))

                                        ; Don't coalesce for high precision scrolling
;; (advice-add 'pixel-scroll-precision :around #'filter-mwheel-never-coalesce)

                                        ; Coalesce for default scrolling (which is still used for horizontal scrolling)
                                        ; and text scaling (bound to ctrl + mouse wheel by default).
;; (advice-add 'mwheel-scroll          :around #'filter-mwheel-always-coalesce)
;; (advice-add 'mouse-wheel-text-scale :around #'filter-mwheel-always-coalesce)
#+end_src

Sometimes, I need to scroll up or down to get a bit more context, but I don't
want my cursor to move.

#+begin_src emacs-lisp
;;;###autoload
(defun daf/scroll-up-line-by-five ()
  (interactive)
  (scroll-up-line 5))

;;;###autoload
(defun daf/scroll-down-line-by-five ()
  (interactive)
  (scroll-down-line 5))

(map! :n "C-e" #'daf/scroll-down-line-by-five
      :n "C-y" #'daf/scroll-up-line-by-five)

(daf/repeat-map! daf-scroll-line-repeat-map
                 '((daf/scroll-up-line-by-five   . "y")
                   (daf/scroll-up-line-by-five   . "t")
                   (daf/scroll-down-line-by-five . "e")
                   (daf/scroll-down-line-by-five . "s"))
                 "Repeatable map for scrolling lines")
#+end_src

While we're at it, let's declare some function to scroll around the buffer.
Especially useful when reading books.

#+begin_src emacs-lisp
(defun daf/scroll-bottom-line-to-top ()
  "Move the bottom line of the buffer to the top, then pulse the line."
  (interactive)
  (evil-window-bottom)
  (evil-scroll-line-to-top (line-number-at-pos))
  (pulsar-pulse-line))

(defun daf/scroll-top-line-to-bottom ()
  "Move the top line of the buffer to the bottom, then pulse the line."
  (interactive)
  (evil-window-top)
  (evil-scroll-line-to-bottom (line-number-at-pos))
  (pulsar-pulse-line))
#+end_src

** FIXME ~Tramp~

Fix weird problems due to prompt, I don't know, wild c/c from google.

#+BEGIN_SRC emacs-lisp
(after! tramp
  (setq tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*"))
#+END_SRC

#+begin_src emacs-lisp
;; (after! tramp (advice-add 'doom--recentf-file-truename-fn :override
;; (defun my-recent-truename (file &rest _args)
;; (if (or (not (file-remote-p file)) (equal "sudo" (file-remote-p file 'method)))
;; (abbreviate-file-name (file-truename (tramp-file-local-name file)))
;; file))))
#+end_src

** Calendar stuff

#+begin_quote
    We are in France, we speak French‚Ä¶ Ok?

‚ÄïChabal
#+end_quote

The week starts on a Monday, as god intended (I think, maybe not, I don't read the
bible).

#+begin_src emacs-lisp
(setq calendar-week-start-day     1
      calendar-time-zone-style    'numeric
      calendar-date-style         'european
      calendar-time-display-form
      '( 24-hours ":" minutes
         (when time-zone (format "(%s)" time-zone))))

;; FIXME
(map! :after (evil evil-org org)
      :map org-agenda-mode-map
      [return] #'org-agenda-goto
      [S-return] #'org-agenda-switch-to)
#+end_src

** General stuff

I don't see a correlation between being zen and being blind.

#+begin_src emacs-lisp
(setq +zen-text-scale 0)
#+end_src

Set default major mode to ~text-mode~.

#+begin_src emacs-lisp
(setq default-major-mode 'text-mode)
#+end_src

#+begin_quote
    When I bring up Doom's scratch buffer with =SPC x=, it's often to play with
    elisp or note something down (that isn't worth an entry in my notes). I can
    do both in `lisp-interaction-mode'.

‚Äïhlissner
#+end_quote

#+begin_src emacs-lisp
(setq doom-scratch-initial-major-mode 'lisp-interaction-mode)
#+end_src

Starts Emacs maximized in graphical mode.

#+begin_src emacs-lisp
(when (display-graphic-p)
  (toggle-frame-maximized))
#+end_src

Let's use ~hippie-expand~ instead of ~dabbrev-expand~.

#+begin_src emacs-lisp
(global-set-key [remap dabbrev-expand] 'hippie-expand)
#+end_src

Access =leaderkey= in the minibuffer with =M-SPC=.

#+begin_src emacs-lisp
(map! :map minibuffer-local-map doom-leader-alt-key #'doom/leader)
#+end_src

Change the symbol used with the inline evaluation =gr=, =gR=.

#+begin_src emacs-lisp
(setq eros-eval-result-prefix "‚áí ") ; default =>
#+end_src

+It's not the size of your indentation that matters, it's how you use it!+

Nevermind, hit an error: tab-with must be set to 8 in org-mode buffers‚Ä¶

#+begin_src emacs-lisp
;; (setq tab-width 4)
#+end_src

Toggle popup with =SPC "=.

#+begin_src emacs-lisp
(map!
 :leader
 :nv "\"" #'+popup/toggle)
#+end_src

I'm no "baka"!

Well, maybe I am. But I'm also trying out some mapping function in Emacs Lisp.
Is it how it works ?

#+begin_src emacs-lisp
(setq +doom-quit-messages
      (delete (seq-find
               (lambda (elmt) (string-match-p "baka" elmt))
               +doom-quit-messages)
              +doom-quit-messages))
#+end_src

** Remove lines

#+begin_src emacs-lisp
(defun daf/join-lines ()
  "Remove all blank lines with `delete-blank-lines', then call `join-line'."
  (interactive)
  (setq thisblank (looking-at "[ \t]*$"))
  (delete-blank-lines)
  (if thisblank (delete-blank-lines))
  (join-line))
#+end_src

#+begin_src emacs-lisp
(map!
 (:prefix ("," . "daf")
  :desc "Join lines" :nv [tab]  #'daf/join-lines))
#+end_src

** Expand region

When using ~evil-mode~, you can rebind =v= to ~er/expand-region~, this is super
useful, keep hitting =v= to further expand the selection!

#+begin_src emacs-lisp
(map!
 :map 'override
 :v "v" #'er/expand-region
 :v "V" #'er/contract-region)
#+end_src

** Window ¬∑ Ó≠ø

I often need to lock/unlock a window size, let's have an interactive function.

FIXME: Seems broken

#+begin_src emacs-lisp
;;;###autoload
(defun daf/window-toggle-lock-size ()
  "Lock/unlock the current window size."
  (interactive)
  (let ((window (get-buffer-window)))
    (cond ((or (window-size-fixed-p window)
               (window-size-fixed-p window t))
           (daf/window-unlock-size window))
          (t
           (daf/window-lock-size window)))))

;;;###autoload
(defun daf/window-lock-size (&optional window)
  "Lock the current window size."
  (interactive)
  (let ((window (or window (get-buffer-window))))
    (message "locking current window size")
    (window-preserve-size window t t)))

;;;###autoload
(defun daf/window-unlock-size (&optional window)
  "Unlock the current window size."
  (interactive)
  (let ((window (or window (get-buffer-window))))
    (message "unlocking current window size")
    (window-preserve-size window t nil)))

;;;###autoload
(defun daf/window-shrink-and-lock ()
  "Shrink and lock the current window size."
  (interactive)
  (let* ((window  (get-buffer-window))
         (curr-h  (window-height window))
         (curr-w  (window-width window))
         (delta-h    (- 5 curr-h))
         (delta-w    (- 5 curr-w)))
    (save-excursion
      (save-selected-window (select-window window)
                            (enlarge-window delta-w delta-h)
                            (daf/window-lock-size window)))))
#+end_src

And add some bindings.

#+begin_src emacs-lisp
(map! :leader
      (:prefix "w"
       :desc "daf/toggle-lock" "," #'daf/window-toggle-lock-size
       :desc "daf/shrink"      "." #'daf/window-shrink-and-lock))
#+end_src

-----

* Level 4: Command Control ¬∑ /Doom, but it's _my_ personal hell/

/Here, I'll put configuration for the modules built-in ~Doom~. Either grouped by
package, or by category./

** Themes ¬∑ pretty little thing ~:ui~
*** Themes

Let us define a dark and a light theme. We'll setup ~Circadian~ later on to manage
them.

#+begin_src emacs-lisp
(defvar daf/dark-theme  'doom-gruvbox)
(defvar daf/light-theme 'ef-eagle)
#+end_src

~doom-gruvbox~'s org headings are a bit blend, lets pimp 'em with some nice colors
borrowed from ~everforest~.

#+begin_src emacs-lisp
(setq everforest-hard-dark-cyan    "#83c092"
      everforest-hard-dark-blue    "#7fbbb3"
      everforest-hard-dark-purple  "#d699b6"
      everforest-hard-dark-green   "#a7c080"
      everforest-hard-dark-red     "#e67e80"
      everforest-hard-dark-orange  "#e69875"
      everforest-hard-dark-yellow  "#ddbc7f"
      everforest-hard-dark-gray    "#323c41"
      everforest-hard-dark-silver  "#9da9a0"
      everforest-hard-dark-black   "#2b3339")

(custom-theme-set-faces! 'doom-gruvbox
  `(org-level-1     :foreground ,everforest-hard-dark-green)
  `(org-level-2     :foreground ,everforest-hard-dark-red)
  `(org-level-3     :foreground ,everforest-hard-dark-purple)
  `(org-level-4     :foreground ,everforest-hard-dark-orange)
  `(org-level-5     :foreground ,everforest-hard-dark-blue)
  `(org-level-6     :foreground ,everforest-hard-dark-silver)
  `(org-level-7     :foreground ,everforest-hard-dark-cyan)
  `(org-level-8     :foreground ,everforest-hard-dark-yellow)
  `(hl-line         :background ,(doom-lighten (doom-color 'base3) 0.10)))
#+end_src

Let us have a nice and easy way to toggle between the two themes.

#+begin_src emacs-lisp
(defun daf/toggle-themes ()
  "Toggle between light and dark themes."
  (interactive)
  (if (eq (car custom-enabled-themes) daf/dark-theme)
      (progn
        (disable-theme daf/dark-theme)
        (load-theme daf/light-theme t))
    (progn
      (disable-theme daf/light-theme)
      (load-theme daf/dark-theme t))))

(map! :leader
      (:prefix ("t" . "toggle")
       :desc "Theme" :mvn "t" #'daf/toggle-themes))
#+end_src

*** Fonts

We'll setup some font stuff here too. But the ~fontaine~ package is used to setup most of it.
Also, there's a fix to some shenanigan happening with the emojis.

#+begin_src emacs-lisp
(setq doom-font                (font-spec :family "Maple Mono NF" :size 11.5)
      doom-variable-pitch-font (font-spec :family "Maple Mono NF")
      doom-symbol-font         (font-spec :family "JuliaMono")
      doom-emoji-font          (font-spec :family "Twitter Color Emoji"))
#+end_src

Enable ~mixed-pitched-mode~ in ~org-mode~.

#+begin_src emacs-lisp
(use-package! mixed-pitch
  :hook (org-mode . mixed-pitch-mode)
  :config
  (setq mixed-pitch-set-heigth t))
#+end_src

*** Splash screen

Ferris is just too cute, I need to see him everyday‚Ä¶

Now come with more cute dinos! ü¶ñ

#+begin_src emacs-lisp
(setq fancy-splash-images
      (list
       (expand-file-name "misc/splash-images/ferris.svg" doom-user-dir)
       (expand-file-name "misc/splash-images/angrytrex.png" doom-user-dir)
       (expand-file-name "misc/splash-images/happystego.png" doom-user-dir)))

(setq fancy-splash-image (nth (random (length fancy-splash-images)) fancy-splash-images))
#+end_src

‚Ä¶and only him, remove the dashboard shortcuts, I'll customize them later anyway.

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
;; (setq +doom-dashboard-functions '(doom-dashboard-widget-banner))
#+end_src

*** Dashboard
**** Overview

|--------------------------+----------------------------------+----------------------|
| Keybind(s)               | Emacs Command                    | Description          |
|--------------------------+----------------------------------+----------------------|
| =SPC D=                    | ~+doom-dashboard/open~             | Open the dashboard   |
|--------------------------+----------------------------------+----------------------|
| _+doom-dashboard-mode-map_ |                                  |                      |
|                          |                                  |                      |
| =f=                        | ~find-file~                        | Find file            |
| =r=                        | ~consult-recent-file~              | Recent files         |
| =R=                        | ~doom/restart-and-restore~         | Restore last session |
| =C=                        | ~doom/open-private-config~         | Doom config dir      |
| =c=                        | [‚Ä¶]                              | Open =config.org=      |
| =.=                        | [‚Ä¶]                              | Open =~/.config=       |
| =n=                        | ~org-roam-node-find~               | Notes org-roam       |
| =b=                        | ~+vertico/switch-workspace-buffer~ | Switch buffer        |
| =B=                        | ~consult-buffer~                   | Switch buffer (all)  |
| =i=                        | ~ibuffer~                          | IBuffer              |
| =p=                        | ~projectile-switch-project~        | Projects             |
| =t=                        | ~consult-theme~                    | Set theme            |
| =Q=                        | ~save-buffers-kill-terminal~       | Quit                 |
| =h=                        | [‚Ä¶]                              | Show keybindings     |
|--------------------------+----------------------------------+----------------------|
**** Configuration & Mapping

#+begin_quote
    When using the dashboard, there are often a small number of actions I will take.
    As the dashboard is it's own major mode, there is no need to suffer the tyranny
    of unnecessary keystrokes --- we can simply bind common actions to a single key!

‚ÄïTecosaur
#+end_quote

‚òù What he says, also adding some shortcuts of my own.

#+begin_src emacs-lisp
(defun +daf/doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file"            :ne "f" #'find-file
        :desc "Recent files"         :ne "r" #'consult-recent-file
        :desc "Restore last session" :ne "R" #'doom/restart-and-restore
        :desc "Doom config dir"      :ne "C" #'doom/open-private-config
        :desc "Open config.org"      :ne "c" (cmd! (find-file (expand-file-name "config.org" doom-user-dir)))
        :desc "Open dotfile"         :ne "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)"         :ne "n" #'org-roam-node-find
        :desc "Switch buffer"        :ne "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ne "B" #'consult-buffer
        :desc "IBuffer"              :ne "i" #'ibuffer
        :desc "Projects"             :ne "p" #'projectile-switch-project
        :desc "Set theme"            :ne "t" #'consult-theme
        :desc "GTD engage"           :ne "z" #'org-gtd-engage
        :desc "Quit"                 :ne "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings"     :ne "h" (cmd! (which-key-show-keymap '+daf/doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+daf/doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+daf/doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+daf/doom-dashboard-setup-modified-keymap))
#+end_src

#+begin_quote
    Unfortunately the show keybindings help doesn't currently work as intended, but
    this is still quite nice overall.

    Now that the dashboard is so convenient, I'll want to make it easier to get to.

‚ÄïTecosaur
#+end_quote

#+begin_src emacs-lisp
(map! :leader :desc "Dashboard" "D" #'+doom-dashboard/open)
#+end_src

*** Modeline
**** Configuration

What is that little ball in the left bottom doing anyway? Remove it!

#+begin_src emacs-lisp
(advice-add #'doom-modeline-segment--modals :override #'ignore)
#+end_src

#+begin_quote
    However, by default red text is used in the modeline, so let‚Äôs make that orange
    so I don‚Äôt feel like something‚Äôs gone wrong when editing files.

‚ÄïTecosaur
#+end_quote

#+begin_src emacs-lisp
(custom-set-faces!
  '(doom-modeline-buffer-modified :foreground "orange"))
#+end_src

Let's simplify the ~doom-modeline~, since some information will be redundant with
the ~nano-modeline~.

#+begin_src emacs-lisp
(setq doom-modeline-position-column-line-format '(""))
#+end_src

Since we have two modelines (we at Dafos Corporation‚Ñ¢  spare no expense), it would be handy to disable the ~doom-modeline~ via a shortcut =SPC t m=.

#+begin_src emacs-lisp
(map!
 :leader (:prefix ("t" . "toggle")
          :desc "Doom Modeline" "m" #'hide-mode-line-mode))
#+end_src

By default, I want only the ~nano-modeline~ visible. I only need ~doom-modeline~ if
I am in a buffer with lsp enabled.

#+begin_src emacs-lisp
(global-hide-mode-line-mode 1)

;;;###autoload
(defun daf/turn-on-mode-line ()
  (if hide-mode-line-mode
      (hide-mode-line-mode -1)))

(add-hook 'lsp-after-open-hook 'daf/turn-on-mode-line)
#+end_src

*** Window select
**** Configuration & Mapping

I guess I don't know what vertical and horizontal mean. My brain want the
opposite of what ~ace-window~ is doing.

#+begin_src emacs-lisp
(setq aw-dispatch-alist
      '((?d aw-delete-window "Delete Window")
        (?m aw-swap-window "Swap Windows")
        (?M aw-move-window "Move Window")
        (?c aw-copy-window "Copy Window")
        (?j aw-switch-buffer-in-window "Select Buffer")
        (?n aw-flip-window)
        (?u aw-switch-buffer-other-window "Switch Buffer Other Window")
        (?e aw-execute-command-other-window "Execute Command Other Window")
        (?F aw-split-window-fair "Split Fair Window")
        (?k aw-split-window-vert "Split Vert Window")
        (?v aw-split-window-horz "Split Horz Window")
        (?o delete-other-windows "Delete Other Windows")
        (?T aw-transpose-frame "Transpose Frame")
        ;; ?i ?r ?t are used by hyperbole.el
        (?? aw-show-dispatch-help)))
#+end_src

*** Workspace
**** Mapping

Invert Switch workspace and Display tab bar mapping. Also add some commodity
shortcuts.

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("TAB" . "workspace")
       :desc "Select workspace"          :mvn "TAB" #'+workspace/switch-to
       :desc "Switch to right workspace" :mvn "¬ª"   #'+workspace/switch-right
       :desc "Switch to left workspace"  :mvn "¬´"   #'+workspace/switch-left
       :desc "Display tab bar"           :mvn "."   #'+workspace/display))

(map! :n "C-t" nil
      :n "gt" nil
      :n "g¬ª" #'+workspace/switch-right
      :n "g¬´" #'+workspace/switch-left)
#+end_src

*** Whitespace
**** Mapping

Toggle display whitespaces with =SPC t SPC=. It's a bit hacky, I need to toggle
the ~global-whitespace-mode~ and revert the buffer afterward.

#+begin_src emacs-lisp
(map!
 :leader
 :prefix ("t" . "toggle")
 :desc "Whitespaces" "SPC" #'daf/show-whitespaces)

(defun daf/show-whitespaces ()
  (interactive)
  (global-whitespace-mode 'toggle)
  (revert-buffer))
#+end_src

*** ~vc-gutter~
**** Configuration & Mapping

Add some bindings for hunk navigation =g (= , =g )=.

#+begin_src emacs-lisp
(defun daf/prev-hunk ()
  "Navigate hunk via vc-gutter or diff-hunk"
  (interactive)
  (condition-case err
      (+vc-gutter/previous-hunk)
    (user-error
     (message "User error: %s" (error-message-string err))
     (diff-hunk-prev))))

(defun daf/next-hunk ()
  "Navigate hunk via vc-gutter or diff-hunk"
  (interactive)
  (condition-case err
      (+vc-gutter/next-hunk)
    (user-error
     (message "User error: %s" (error-message-string err))
     (diff-hunk-next))))

(map!
 :prefix "g"
 :n ")" #'daf/next-hunk
 :n "(" #'daf/prev-hunk)
#+end_src

And make it repeatable.

#+begin_src emacs-lisp
(daf/repeat-map! daf-navigate-hunk-repeat-map
                 '((daf/next-hunk . ")")
                   (daf/prev-hunk . "(")
                   (daf/prev-hunk . "p")
                   (daf/next-hunk . "n"))
                 "Repeatable map for navigating hunks")
#+end_src

** Completion ¬∑ ~:completion~
*** ~consult~
**** Configuration & Mapping

By default, ~consult-narrow-key~ is set to =<=, =¬´= is more reachable in a b√©po
keyboard.

#+begin_src emacs-lisp
(setq consult-narrow-key "¬´")
#+end_src

Add integration between ~Embark~ and ~Consult~.

#+begin_src emacs-lisp
(use-package! embark-consult
  :after (embark consult)
  :hook
  (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src


I snatch this one from ~LemonBreezes~. Allows to preview with ~consult~ in a few
different places.

#+begin_src emacs-lisp
(use-package! consult
  :when (modulep! :completion vertico)
  :defer t
  :init
  :config
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any))
  (setq consult-preview-key
        '(:debounce 0.4 any))
  (add-to-list 'consult-preview-allowed-hooks
               'global-org-modern-mode-check-buffers)
  (add-to-list 'consult-preview-allowed-hooks
               'global-hl-todo-mode-check-buffers)
  (consult-customize
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file
   consult--source-recent-file consult--source-project-recent-file
   consult--source-bookmark
   :preview-key 'any)
  (when (modulep! :config default)
    (consult-customize
     +default/search-project +default/search-other-project
     +default/search-project-for-symbol-at-point
     +default/search-cwd +default/search-other-cwd
     +default/search-notes-for-symbol-at-point
     +default/search-emacsd
     :preview-key 'any))
  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window))
#+end_src

Send ~consult-line~ search pattern to the evil search history ring.
Basically, =SPC s s= ‚Üí =ret= ‚Üí =n= ‚Üí =n= ‚Ä¶

Courtesy of [[https://github.com/minad/consult/issues/318#issuecomment-882067919][noctuid ÔÇõ]].

#+begin_src emacs-lisp
(defun daf/consult-line-evil-history (&rest _)
  "Add latest `consult-line' search pattern to the evil search history ring.
This only works with orderless and for the first component of the search."
  (when (and (bound-and-true-p evil-mode)
             (eq evil-search-module 'evil-search))
    (let ((pattern (car (orderless-pattern-compiler (car consult--line-history)))))
      (add-to-history 'evil-ex-search-history pattern)
      (setq evil-ex-search-pattern (list pattern t t))
      (setq evil-ex-search-direction 'forward)
      (when evil-ex-search-persistent-highlight
        (evil-ex-search-activate-highlight evil-ex-search-pattern)))))

(advice-add #'consult-line :after #'daf/consult-line-evil-history)
#+end_src

Finally, let's define some bindings.

#+begin_src emacs-lisp
(map!
 :leader
 (:prefix ("s" . "search")
  :desc "Search .emacs.d"       "E" #'+default/search-emacsd
  :desc "Locate file"           "f" #'+vertico/consult-fd-or-find
  :desc "Jump to errors"        "e" #'consult-flymake
  :desc "Jump to global marks"  "R" #'consult-global-mark
  :desc "Search macros"         "q" #'consult-kmacro)
 (:prefix ("h" . "help")
  :desc "(Wo)Man" "W" #'consult-man))

(map!
 :map org-mode-map
 :leader
 (:prefix ("s" . "search")
  :desc "Jump to org headings" "." #'consult-org-heading))
#+end_src

*** ~embark~
**** Configuration & Mapping

=C-;= is three key presses in a b√©po keyboard, let's add a more accessible
binding.

#+begin_src emacs-lisp
(map! [remap describe-bindings] #'embark-bindings
      "C-," #'embark-act
      "M-," #'embark-dwim
      "C-?" #'embark-bindings)
#+end_src

Open a buffer from ~consult~ and split using ~ace-window~.

Typically, I would use it like this:
1. =SPC SPC= for ~find-file~
2. highlight desired file
3. =C-,= to open the ~embark~ menu
4. =o= to invoke the ~ace-window~ action
5. =v= or =k= to indicate a direction to split

#+begin_src emacs-lisp
(after! embark
  (eval-when-compile
    (defmacro daf/embark-ace-action (fn)
      `(defun ,(intern (concat "daf/embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (require 'ace-window)
           (let ((aw-dispatch-always t))
             (aw-switch-to-window (aw-select nil))
             (call-interactively (symbol-function ',fn)))))))

  (define-key embark-file-map     (kbd "o") (daf/embark-ace-action find-file))
  (define-key embark-buffer-map   (kbd "o") (daf/embark-ace-action switch-to-buffer))
  (define-key embark-bookmark-map (kbd "o") (daf/embark-ace-action bookmark-jump)))
#+end_src

*** ~vertico~
**** Overview

|------------+------------------------+---------------------------|
| Keybind(s) | Emacs Command          | Description               |
|------------+------------------------+---------------------------|
| =M-o c=      | ~consult-toggle-preview~ | Toggle preview in ~vertico~ |
|            |                        |                           |
|------------+------------------------+---------------------------|
**** Configuration

~vertico~ allows us to choose which completion style we want for various
commands/categories.

I want ~consult-grep~ commands in a left side window, whereas the other commands
should appear in the bottom.

#+begin_src emacs-lisp
(after! vertico
  (vertico-multiform-mode)

  (setq vertico-mouse-mode             't
        vertico-multiform-commands     '((consult-line buffer))
        vertico-multiform-categories   '((consult-grep buffer))
        vertico-buffer-display-action  '(display-buffer-in-side-window
                                         (side . left)
                                         (window-width . 0.4))))

(autoload #'consult--read "consult")

;;;###autoload
(defun +daf/vertico/projectile-completion-fn (prompt choices)
  "Given a PROMPT and a list of CHOICES, filter a list of files for
`projectile-find-file'."
  (interactive)
  (consult--read
   choices
   :prompt prompt
   :sort nil
   :add-history (thing-at-point 'filename)
   :category 'file
   :history '(:input +vertico/find-file-in--history)))

(setq projectile-completion-system '+daf/vertico/projectile-completion-fn)

#+end_src

#+begin_src emacs-lisp
(defvar-local consult-toggle-preview-orig nil)

(defun daf/consult-toggle-preview ()
  "Command to enable/disable preview."
  (interactive)
  (if consult-toggle-preview-orig
      (setq consult--preview-function   consult-toggle-preview-orig
            consult-toggle-preview-orig nil)
    (setq consult-toggle-preview-orig consult--preview-function
          consult--preview-function   #'ignore)))

;; Bind to `vertico-map' or `selectrum-minibuffer-map'
(after! vertico
  (define-key vertico-map (kbd "M-o c") #'daf/consult-toggle-preview))
#+end_src

=C-n= and =C-p= to navigate groups.

#+begin_src emacs-lisp
(map!
 :map vertico-map
 "C-n" #'vertico-next-group
 "C-p" #'vertico-previous-group)
#+end_src

** Editor ¬∑ ~:editor~
*** ~evil~ ¬∑ the necessary one

/As a Vim refugee, evil allows me to be somewhat productive in an editor, I
should at least try to immerse myself in the default Emacs's binding, someday‚Ä¶/

**** Overview

|------------+----------------------------+-------------------------|
| Keybind(s) | Emacs Command              | Description             |
|------------+----------------------------+-------------------------|
| =q=          | ~eval-quit~                  | Quit                    |
| =Q=          | ~evil-record-macro~          | Record macro            |
| =, ,=        | ~evil-avy-goto-char-timer~   | Go to char with timer   |
| =, SPC=      | ~avy-goto-word-0~            | Go to word              |
| =, l=        | ~avy-goto-line~              | Go to line              |
| =C-==        | ~daf/toggle-window-enlargen~ | Toggle window enlarging |
| =z tab=      | ~+fold/toggle~               | Toggle fold             |
| =√ß r= / =√ß √ß=  | ~rotate-text~                | Cycle word under cursor |
|            |                            |                         |
|------------+----------------------------+-------------------------|
- *commands for resizing windows are repeatable*

**** Configuration & Mapping

But not *too* evil, please. Allows to use Emacs default bindings in insert mode.

#+begin_src emacs-lisp
(after! evil
  (setq evil-disable-insert-state-bindings t
        evil-want-fine-undo 'yes))
#+end_src

When creating window splits, it's nice to jump straight to them.

#+begin_src emacs-lisp
(after! evil
  (setq evil-split-window-below  t
        evil-vsplit-window-right t))
#+end_src

Save a few key strokes, open up ~dired~ while we're at it.

#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (dired-jump))
#+end_src

I like my ~s/../..~ to be global by default.

#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t))
#+end_src

I use =o=, =O= often, but not much for appending comments, let's disable that.

#+begin_src emacs-lisp
(after! evil
  (setq +evil-want-o/O-to-continue-comments nil))
#+end_src

FIXME ~evil-surround~ is acting up, refusing to load, and requiring to manually enable.

#+begin_src emacs-lisp
(after! evil
  (setq global-evil-surround-mode 1))
#+end_src

Habits die hard. I use =q= to close most things. I want to close buffer too. This
means ~macros~ should be mapped to =Q=.

#+begin_src emacs-lisp
(map!
 :map evil-normal-state-map
 :after evil
 ("q" #'evil-quit)
 ("Q" #'evil-record-macro))
#+end_src

~avy-goto-char-timer~ is one of the most useful things ever, let's make it more
accessible (=,,=).

#+begin_src emacs-lisp
(map! (:after evil-easymotion
              (:prefix (",")
               :desc "Go to word"            :nv "SPC" #'avy-goto-word-0
               :desc "Go to line"            :nv "l"   #'avy-goto-line
               :desc "Go to char with timer" :nv ","   (cmd! (let ((current-prefix-arg t)) (evil-avy-goto-char-timer))))))

(map! (:after evil-easymotion
       :m "g√©" evilem-map
       (:map evilem-map
             "√©" (cmd! (let ((current-prefix-arg t)) (evil-avy-goto-char-timer))))))
#+end_src

I like to resize pane, but I don't like to repeat the same key sequence a bunch.
So let's make it repeatable.

#+begin_src  emacs-lisp
;;;###autoload
(defun +daf/evil-window-increase-width-by-five (count)
  "wrapper call associated function by step of five"
  (interactive "p")
  (evil-window-increase-width (+ count 5)))

;;;###autoload
(defun +daf/evil-window-decrease-width-by-five (count)
  "wrapper call associated function by step of five"
  (interactive "p")
  (evil-window-decrease-width (+ count 5)))

;;;###autoload
(defun +daf/evil-window-increase-height-by-three (count)
  "wrapper call associated function by step of three"
  (interactive "p")
  (evil-window-increase-height (+ count 3)))

;;;###autoload
(defun +daf/evil-window-decrease-height-by-three (count)
  "wrapper call associated function by step of three"
  (interactive "p")
  (evil-window-decrease-height (+ count 3)))

(map! (:map evil-window-map
            "+" #'+daf/evil-window-increase-height-by-three
            "-" #'+daf/evil-window-decrease-height-by-three
            "¬´" #'+daf/evil-window-decrease-width-by-five
            "<" #'+daf/evil-window-decrease-width-by-five
            ">" #'+daf/evil-window-increase-width-by-five
            "¬ª" #'+daf/evil-window-increase-width-by-five))
#+end_src

#+begin_src emacs-lisp
(daf/repeat-map! daf-window-resize-repeat-map
                 '((+daf/evil-window-increase-height-by-three . "+")
                   (+daf/evil-window-increase-height-by-three . "=")
                   (+daf/evil-window-decrease-height-by-three . "-")
                   (+daf/evil-window-increase-width-by-five   . "¬ª")
                   (+daf/evil-window-increase-width-by-five   . ">")
                   (+daf/evil-window-decrease-width-by-five   . "¬´")
                   (+daf/evil-window-decrease-width-by-five   . "<"))
                 "Repeatable map for window resizing")
#+end_src

Enlarging window should be easier to do, let's define a function to toggle it
with =C-==.

#+begin_src emacs-lisp
;;;###autoload
(defun daf/toggle-window-enlargen (&optional window)
  "Toggle window enlarging. Run again to winner-undo."
  (interactive)
  (setq window (window-normalize-window nil))
  (cond
   ((or (> (window-max-delta window nil nil nil nil nil window-resize-pixelwise) 0)
        (> (window-max-delta window t nil nil nil nil window-resize-pixelwise) 0))
    (doom/window-enlargen))
   (t (winner-undo))))

(map! :ni "C-=" #'daf/toggle-window-enlargen)
#+end_src

*** ~fold~ ¬∑ ¬´ Look, Ma! No arms! ¬ª
**** Mapping

Quickly toggle ~folds~.

#+begin_src emacs-lisp
(after! evil
  (map!
   :n "z <tab>" #'+fold/toggle))
#+end_src

** Emacs ¬∑ ~:emacs~ itself
*** ~undo-fu~
**** Configuration

Undoing in region seems really great, I still have trouble to use it sometimes,
though. The binding =C-_= is not really accessible with my layout unfortunately.

#+begin_src emacs-lisp
(setq undo-fu-allow-undo-in-region 't)
#+end_src

*** ~ediff~
**** Configuration

Take A or B, why not both ?

#+begin_src emacs-lisp
(defun daf/ediff-copy-both-to-C ()
  (interactive)
  (ediff-copy-diff
   ediff-current-difference nil 'C nil
   (concat
    (ediff-get-region-contents
     ediff-current-difference 'A ediff-control-buffer)
    (ediff-get-region-contents
     ediff-current-difference 'B ediff-control-buffer))))

(defun daf/add-d-to-ediff-mode-map ()
  (define-key ediff-mode-map "d" 'daf/ediff-copy-both-to-C))

(add-hook 'ediff-keymap-setup-hook 'daf/add-d-to-ediff-mode-map)
#+end_src

*** ~dired~ ¬∑ ¬´ Our last resort, in these dire times ¬ª
**** TODO Overview
**** Configuration

Open file with external application from ~Dired~.

#+begin_src emacs-lisp
(defun daf/dired-open-file ()
  "In Dired, open the file named on this line."
  (interactive)
  (let* ((file (dired-get-filename nil t)))
    (message "Opening %s..." file)
    (call-process "xdg-open" nil 0 nil file)
    (message "Opening %s done" file)))
#+end_src

**** Mapping

Conveniently, Doom doesn't use =SPC d= and I use ~Dired~ often, so let's add a few
key bindings.

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("d" . "Dired")
       :desc "Dired"                       "." #'dired
       :desc "Dired jump to current"       "d" #'dired-jump
       :desc "fd input to Dired"           "f" #'fd-dired
       :desc "Dired into project root"     "p" #'project-dired
       :desc "Open Dired in another frame" "D" #'dired-other-window))
#+end_src

~dirvish~ makes navigating directories so much pleasant! Let's change a bit of key
bindings.

#+begin_src emacs-lisp
(after! dired
  (map! :leader
        :prefix ("t" . "toggle")
        :desc "Side bar" :mvn "d" #'dirvish-side)
  (map! :after dirvish
        :map dirvish-mode-map
        :n "s" #'dired-previous-line
        :n "N" #'dirvish-narrow)
  (map!
   :map dired-mode-map
   :n "g."    #'dired-omit-mode
   :n "c"     #'dired-up-directory
   :n "s"     #'dired-previous-line
   :n "M-RET" #'daf/dired-open-file
   :n "R"     #'dired-do-rename
   :n "L"     #'dired-do-copy
   :n "r"     #'dired-find-file))
#+end_src

** Term ¬∑ ~:term~ inally ill

I still need to learn to *stay* in Emacs when in comes to shell, but luckily we
have ~eshell~ and ~vterm~ for that. I am still undecided between the two, so I use
them both!

*** ~eshell~
**** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! aweshell
  :recipe (:host github
           :repo "manateelazycat/aweshell")) ;; https://github.com/manateelazycat/aweshel
#+end_src

#+begin_src emacs-lisp
(use-package! aweshell
  :defer t
  :commands (aweshell-new aweshell-dedicated-open))
#+end_src

*** ~vterm~
**** Configuration & Mapping

#+begin_src emacs-lisp
(use-package! vterm
  :hook (vterm-mode . daf/vterm-font-setup)

  :config
  (setf (alist-get "woman" vterm-eval-cmds nil nil #'equal)
        '((lambda (topic)
            (woman topic))))
  (setf (alist-get "magit-status" vterm-eval-cmds nil nil #'equal)
        '((lambda (path)
            (magit-status path))))
  (setf (alist-get "dired" vterm-eval-cmds nil nil #'equal)
        '((lambda (dir)
            (dired dir))))
  (set-popup-rules!
    '(("^\\*doom:vterm.*"
       :slot 1 :vslot -2
       :actions (+popup-display-buffer-stacked-side-window-fn)
       :side bottom :width 0.5 :height 0.55 :quit 'other :ttl nil))))
#+end_src

I had some visual issue with my default font when rendering some symbols in the
prompt. So lets set a specific font for ~vterm~.

#+begin_src emacs-lisp
(when (modulep! :term vterm)
  (defun daf/vterm-font-setup ()
    "Sets a fixed width (monospace) font in current buffer"
    (set (make-local-variable 'buffer-face-mode-face)
         '(:family "MonaspiceKr Nerd Font Propo"))
    (face-remap-add-relative 'fixed-pitch)
    (buffer-face-mode t)))
#+end_src

~eshell~ has helpful functions to open a split right and bellow, lets do the same
for ~vterm~.

#+begin_src emacs-lisp
(when (modulep! :term vterm)
  (defun +daf/vterm/split-right ()
    "Create a new vterm window to the right of the current one."
    (interactive)
    (let* ((ignore-window-parameters t)
           (dedicated-p (window-dedicated-p)))
      (select-window (split-window-horizontally))
      (+vterm/here default-directory)))

  (defun +daf/vterm/split-below ()
    "Create a new vterm window below the current one."
    (interactive)
    (let* ((ignore-window-parameters t)
           (dedicated-p (window-dedicated-p)))
      (select-window (split-window-vertically))
      (+vterm/here default-directory))))
#+end_src

Now lets put all this into a global binding, I'll use =SPC e=.

#+begin_src emacs-lisp
(map! :leader
      :when (modulep! :term vterm)
      (:prefix ("e" . "(e)shell")
       :desc "toggle eshell popup"           "E" #'+eshell/toggle
       :desc "open eshell here"              "e" #'+eshell/here
       :desc "open eshell in project root"   "p" #'project-eshell
       :desc "eshell below"                  "K" #'+eshell/split-below
       :desc "eshell right"                  "V" #'+eshell/split-right
       :desc "toggle vterm popup"            "T" #'+vterm/toggle
       :desc "open vterm here"               "t" #'+vterm/here
       :desc "vterm below"                   "k" #'+daf/vterm/split-below
       :desc "vterm right"                   "v" #'+daf/vterm/split-right))
#+end_src

** Checkers ¬∑ ~:check(er)~ mate
*** ~langtool~
**** Configuration

~langtool~ isn't cutting it for me, I'll setup ~languagetool.el~ latter on.

#+begin_src emacs-lisp :tangle packages.el
(package! langtool :disable t)
#+end_src

*** ~flycheck~
**** Configuration & Mapping

I write mostly bad code, so I need to jump to problems easily.

#+begin_src emacs-lisp
(map!
 (:after flycheck
         (:map flycheck-mode-map
               "M-n" #'flycheck-next-error
               "M-p" #'flycheck-previous-error)))
#+end_src

*** ~flymake~
**** Configuration & Mapping

I write mostly bad code, so I need to jump to problems easily.

#+begin_src emacs-lisp :tangle packages.el
(unpin! flymake)
#+end_src

#+begin_src emacs-lisp
(map!
 (:after flymake
         (:map flymake-mode-map
               "M-n" #'flymake-goto-next-error
               "M-p" #'flymake-goto-prev-error)))
#+end_src

** Tools ¬∑ the sharpest ~:tool~ in the shed
*** ~lookup~ ¬∑ ¬´ Ahh we used to look up at the sky and wonder‚Ä¶¬ª
**** Mapping

In situation when I need to quickly look a word definition to not look too dumb.

#+begin_src emacs-lisp
(map!
 (:when (modulep! :tools lookup)
   :n "z?" #'define-word-at-point))
#+end_src

*** ~magit~
**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
;; (unpin! magit)
(unpin! magit-todos)
(unpin! pcre2el)
(package! with-editor)
#+end_src

Show a list of TODO and other keywords in the ~magit~ status view.

#+begin_src emacs-lisp
(after! magit
  (map!
   :map magit-mode-map
   :n "$"   #'magit-process-buffer
   :n "g¬ª"  #'+workspace/switch-right
   :n "g¬´"  #'+workspace/switch-left
   :n "C-t" #'magit-section-forward-sibling
   :n "C-s" #'magit-section-backward-sibling)
  (map!
   :map magit-status-mode-map
   :n "g("  #'daf/prev-hunk
   :n "g)"  #'daf/next-hunk
   :n "C-t" #'magit-section-forward-sibling
   :n "C-s" #'magit-section-backward-sibling))

;; REVIEW
(after! gv
  (put 'buffer-local-value 'byte-obsolete-generalized-variable nil))

;; FIXME <- oh the irony
;;(use-package! magit-todos
;;:after magit
;;:config
;;(magit-todos-mode 1))
;; (map!
 ;; :leader
 ;; :prefix ("p" . "project")
 ;; :desc "Project todos" :n "t" #'magit-todos-list)
#+end_src

*** ~lsp~ Ó∏ï :ARCHIVE:
**** Configuration

#+begin_src emacs-lisp :tangle packages.el
;; (unpin! lsp-mode)
#+end_src

Let's try to apply some performance recommendation regarding =plists=.

#+begin_src emacs-lisp
;; (setenv "LSP_USE_PLISTS" "1")
;; (setq lsp-use-plists "true")
#+end_src

** App ¬∑ ~:app~ lause please
*** ~emoji~
**** Configuration & Mapping

Remove some Emoji, for which I want to display a symbol.

#+begin_src emacs-lisp
(dolist (char '(?‚è© ?‚è™ ?‚ùì ?‚è∏))
  (set-char-table-range char-script-table char 'symbol))
#+end_src

=SPC i n= to insert ~nerd icons~.

#+begin_src emacs-lisp
(map!
 :leader
 (:prefix ("i" . "insert")
  :desc "Nerd Icons" "n" #'nerd-icons-insert))
#+end_src

*** ~elfeed~
**** Overview

|------------+---------------+-----------------|
| Keybind(s) | Emacs Command | Description     |
|------------+---------------+-----------------|
| =SPC r=      |               | RSS             |
| =SPC r r=    | ~elfeed~        | Elfeed          |
| =SPC r u=    | ~elfeed-update~ | Update feeds    |
| =SPC r .=    | [‚Ä¶]           | Open =elfeed.org= |
|            |               |                 |
|------------+---------------+-----------------|
**** Configuration & Mapping

~Elfeed~ doesn't have a binding by default, conveniently, =SPC r= is available.

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("r" . "rss")
       :desc "Elfeed"          "r" #'=rss
       :desc "Update feeds"    "u" #'elfeed-update
       :desc "Open elfeed.org" "." (cmd!
                                    (find-file
                                     (expand-file-name "elfeed.org" org-directory)))))
#+end_src

Automatically update feed when opening ~Elfeed~.

#+begin_src emacs-lisp
(add-hook! 'elfeed-search-mode-hook #'elfeed-update)
#+end_src

** Org Mode
*** Configuration & Mapping

I use ~syncthing~ to share files between my computers, it's also handy to sync
org files to my phone. Let's setup the org directory.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-directory "~/Sync/Org/")
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil))
#+END_SRC

Let's customize the ~org-todo-keywords~ list.

#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"    ; A task that needs doing & is ready to do
           "NEXT(n)"    ; The next task to do
           "REVIEW(r)"  ; A task being tested/reviewed
           "WAIT(w)"    ; Something external is holding up this task
           "HOLD(h)"    ; This task is paused/on hold because of me
           "MAYBE(m)"   ; A task that might be droped
           "SOMEDAY(s)" ; A task without a precise timebox
           "FIXME(f)"
           "|"
           "DONE(d)"    ; Task successfully completed
           "DROP(D)")   ; Task was cancelled, aborted, or is no longer applicable
          (sequence
           "[ ](T)"     ; A task that needs doing
           "[-](S)"     ; Task is in progress
           "[?](W)"     ; Task is being held up or paused
           "|"
           "[X](D)")    ; Task was completed
          (sequence
           "TOREAD(l)"  ; A book/article to read
           "READING(L)" ; Currently reading
           "|"
           "READ(R)")   ; Done reading
          (sequence
           "|"
           "YES(y)"
           "NO(n)"))
        org-todo-keyword-faces
        '(("[-]"     . +org-todo-active)
          ("[?]"     . +org-todo-onhold)
          ("NEXT"    . +org-todo-active)
          ("WAIT"    . +org-todo-onhold)
          ("REVIEW"  . +org-todo-onhold)
          ("HOLD"    . +org-todo-onhold)
          ("MAYBE"   . +org-todo-onhold)
          ("SOMEDAY" . +org-todo-onhold)
          ("NO"      . +org-todo-cancel)
          ("DROP"    . +org-todo-cancel))))
#+end_src

Display ~hl-todo-keywords~ in ~org-mode~, such as FIXME/TODO/BUG/REVIEW‚Ä¶

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'hl-todo-mode)
#+end_src

There are some handy shortcuts in ~org-mode~ to insert babel /src/ blocks, we can
define some of our own.

#+begin_src emacs-lisp
(use-package! org-tempo
  :after org
  :demand t)
(setq org-structure-template-alist
      '(("s" . "src")
        ("e" . "src emacs-lisp")
        ("E" . "src emacs-lisp :results value code :lexical t")
        ("t" . "src emacs-lisp :tangle packages.el")
        ("c" . "comment")
        ("C" . "center")
        ("n" . "note")
        ("x" . "example")
        ("X" . "export")
        ("v" . "verse")
        ("q" . "quote")))
#+end_src

Some ~or-babel~ blocks might take too much space, so let's have a way to specify
hidden block.

#+BEGIN_SRC emacs-lisp :hidden
(defun daf/individual-visibility-source-blocks ()
  "Fold some blocks in the current buffer."
  (interactive)
  (org-show-block-all)
  (org-block-map
   (lambda ()
     (let ((case-fold-search t))
       (when (and
              (save-excursion
                (beginning-of-line 1)
                (looking-at org-block-regexp))
              (cl-assoc
               ':hidden
               (cl-third
                (org-babel-get-src-block-info))))
         (org-hide-block-toggle))))))

(add-hook 'org-mode-hook (function daf/individual-visibility-source-blocks))
#+END_SRC

#+begin_quote
    Enable Speed Keys, which allows quick single-key commands when the cursor is
    placed on a heading. Usually the cursor needs to be at the beginning of a
    headline line, but defining it with this function makes them active on any of
    the asterisks at the beginning of the line.

‚Äî‚Äî Diego Zamboni
#+end_quote

#+begin_src emacs-lisp
(after! org
  (setq org-use-speed-commands
        (lambda ()
          (and (looking-at org-outline-regexp)
               (looking-back "^\**")))))
#+end_src

I don't use =g c= to navigate org headings, but I often time need to =g c c= to
comment out code in org babel src blocks.

#+begin_src emacs-lisp
(map!
 :after (evil org evil-org)
 :map  evil-org-mode-map
 :nvm "gc" nil
 :nvm "((" #'evil-org-backward-sentence
 :nvm "))" #'evil-org-forward-sentence)
#+end_src

**** Visual

~org~ is pretty great and with ~org-modern~ that I'll setup later, it's pretty
pretty, but let's change some visual stuff anyway.

#+begin_src emacs-lisp
(after! org
  (setq org-auto-align-tags nil
        org-catch-invisible-edits 'show-and-error
        org-ellipsis " "  ;; other option for reference ‚Æß
        org-fontify-quote-and-verse-blocks t
        org-hide-emphasis-markers t
        org-insert-heading-respect-content t
        org-pretty-entities t
        org-special-ctrl-a/e t
        org-tags-column 0))
#+end_src

Set font family for ~org-ellipsis~ to fix some visual bug.

#+begin_src emacs-lisp
(custom-set-faces!
  '(org-ellipsis :family "JuliaMono"))
#+end_src

Hide line numbers in ~org-mode~.

#+begin_src emacs-lisp
(defun daf/hide-line-numbers ()
  (display-line-numbers-mode 0))

(add-hook 'org-mode-hook 'daf/hide-line-numbers)
#+end_src

Let‚Äôs make headings and title a bit bigger.

#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.35)
  '(org-level-1 :weight extra-bold :height 1.30)
  '(org-level-2 :weight bold :height 1.20)
  '(org-level-3 :weight bold :height 1.15)
  '(org-level-4 :weight semi-bold :height 1.13)
  '(org-level-5 :weight semi-bold :height 1.10)
  '(org-level-6 :weight semi-bold :height 1.07)
  '(org-level-7 :weight semi-bold :height 1.05)
  '(org-level-8 :weight semi-bold :height 1.03)
  '(org-level-9 :weight semi-bold))
#+end_src

Finally, lets pimp the symbols across ~org~.

#+begin_src emacs-lisp
;; (add-hook 'org-mode-hook #'+org-pretty-mode)
(setq doom-themes-org-fontify-special-tags nil)
(setq org-priority-highest ?A
      org-priority-lowest  ?D
      org-priority-faces
      '((?A . 'nerd-icons-red)
        (?B . 'nerd-icons-orange)
        (?C . 'nerd-icons-yellow)
        (?D . 'nerd-icons-green)))

(appendq! +ligatures-extra-symbols
          (list :list_property "‚à∑"
                :em_dash       "‚Äî"
                :arrow_right   "‚Üí"
                :arrow_left    "‚Üê"
                :arrow_lr      "‚Üî"
                :scheduled     "ÔÄó"
                :deadline      "Û∞•î"
                :properties    "Û∞ªã"
                :end           "‚åû‚åü"
                :priority_a    #("Ôá¢" 0 1 (face nerd-icons-red))
                :priority_b    #("‚öë" 0 1  (face nerd-icons-orange))
                :priority_c    #("‚öë" 0 1  (face nerd-icons-yellow))))

(defadvice! +org-init-appearance-h--no-ligatures-a ()
  :after #'+org-init-appearance-h
  (set-ligatures! 'org-mode nil)
  (set-ligatures! 'org-mode
    :list_property "::"
    :em_dash       "---"
    :arrow_right   "->"
    :arrow_left    "<-"
    :arrow_lr      "<->"
    :scheduled     "SCHEDULED:"
    :deadline      "DEADLINE:"
    :properties    ":PROPERTIES:"
    :end           ":END:"
    :priority_a    "[#A]"
    :priority_b    "[#B]"
    :priority_c    "[#C]"))
#+end_src

*** ~org-agenda~
**** Configuration & Mapping

Let's start by removing some ~DOOM~ code, this makes ~org-habit~ graph acting weird.

#+begin_src emacs-lisp
(remove-hook! 'org-load-hook #'+org-init-habit-h)
#+end_src

#+begin_src emacs-lisp
(after! org
  (setq org-agenda-files
        (mapcar 'file-truename
                (file-expand-wildcards
                 (expand-file-name "*.org" org-directory)))
        ;; org-agenda-tags-column 20
        org-agenda-include-diary t
        org-agenda-block-separator ?‚îÄ
        org-agenda-hide-tags-regexp ".*"      ;; hide tags in org-agenda
        org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-deadline-is-shown t
        org-agenda-skip-scheduled-if-done t
        org-agenda-skip-timestamp-if-deadline-is-shown t
        org-agenda-skip-timestamp-if-done t
        org-agenda-span 1
        org-agenda-start-day "+0d"
        org-log-into-drawer t
        org-habit-graph-column 55
        org-agenda-time-grid
        '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          " ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ " "‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ")
        org-agenda-current-time-string
        "‚Å£‚Üê‚îÄ‚îÄ now ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        org-agenda-prefix-format
        '(
          (agenda . "  %?-2i %t ")
          (todo   . " %i %-12:c")
          (habits . " %i %-12:c")
          (tags   . " %i %-12:c")
          (search . " %i %-12:c"))
        org-agenda-category-icon-alist
        `(
          ("Family"
           ,(list (nerd-icons-octicon
                   "nf-oct-people"
                   :v-adjust 0.005)) nil nil :ascent center)
          ("Home"
           ,(list (nerd-icons-codicon
                   "nf-cod-home"
                   :v-adjust 0.005)) nil nil :ascent center)
          ("Health"
           ,(list (nerd-icons-mdicon
                   "nf-md-medical_bag"
                   :v-adjust 0.005)) nil nil :ascent center)
          ("Emacs"
           ,(list (nerd-icons-sucicon
                   "nf-custom-emacs"
                   :v-adjust 0.005)) nil nil :ascent center)
          ("KDE"
           ,(list (nerd-icons-flicon
                   "nf-linux-kde"
                   :v-adjust 0.005)) nil nil :ascent center)
          ("NixOS"
           ,(list (nerd-icons-flicon
                   "nf-linux-nixos"
                   :v-adjust 0.005)) nil nil :ascent center)
          ("Knowledge"
           ,(list
             (nerd-icons-faicon
              "nf-fa-database"
              :height 0.8)) nil nil :ascent center)
          ("habit"
           ,(list
             (nerd-icons-mdicon
              "nf-md-calendar_sync"
              :height 0.9)) nil nil :ascent center)
          ("tasks"
           ,(list
             (nerd-icons-codicon
              "nf-cod-tasklist"
              :height 0.9)) nil nil :ascent center)
          ("Home-Assistant"
           ,(list
             (nerd-icons-mdicon
              "nf-md-home_assistant"
              :height 0.9)) nil nil :ascent center)
          ("Book"
           ,(list
             (nerd-icons-codicon
              "nf-cod-book"
              :height 0.9)) nil nil :ascent center)
          ("YouTube"
           ,(list
             (nerd-icons-faicon
              "nf-fa-youtube"
              :height 0.9)) nil nil :ascent center)
          ("Personal"
           ,(list
             (nerd-icons-codicon
              "nf-cod-person"
              :height 0.9)) nil nil :ascent center))))

(map! :leader
      :after org
      :desc "Agenda" "A" #'org-agenda)
#+end_src

Center ~org-agenda~ view.

#+begin_src emacs-lisp
(defun daf/org-agenda-open-hook ()
  "Hook to be run when org-agenda is opened."
  (logos-focus-mode))

(add-hook 'org-agenda-mode-hook 'daf/org-agenda-open-hook)
#+end_src

=C-t= and =C-s=, to navigate between headings.

#+begin_src emacs-lisp
(map! :after org
      :map org-mode-map
      :n "C-t" #'org-next-visible-heading
      :n "C-s" #'org-previous-visible-heading)
#+end_src

¬∑ ÔÜç [[https://emacs.stackexchange.com/questions/21754/how-to-automatically-save-all-org-files-after-marking-a-repeating-item-as-done-i][How to automatically save all org files after marking a repeating item as DONE in the org agenda?]]

Saves ~org-mode~ buffers whenever a schedule/deadline/check todo action is made.

#+begin_src emacs-lisp
(defmacro Œ∑ (fnc)
  "Return function that ignores its arguments and invokes FNC."
  `(lambda (&rest _rest)
     (funcall ,fnc)))

(advice-add 'org-deadline       :after (Œ∑ #'org-save-all-org-buffers))
(advice-add 'org-schedule       :after (Œ∑ #'org-save-all-org-buffers))
(advice-add 'org-store-log-note :after (Œ∑ #'org-save-all-org-buffers))
(advice-add 'org-todo           :after (Œ∑ #'org-save-all-org-buffers))
#+end_src

*** ~org-super-agenda~
/Supercharge your Org daily/weekly agenda by grouping items/
**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda) ;; https://github.com/alphapapa/org-super-agenda
#+end_src

#+begin_src emacs-lisp
(use-package! org-super-agenda
  :defer t
  :after (org org-agenda)
  :commands org-super-agenda-mode

  :config
  (setq org-super-agenda-group-property-name "project-id"
        org-agenda-custom-commands
        '(("o" "Overview"
           ((agenda "" ((org-agenda-span 'day)
                        (org-super-agenda-groups
                         '((:name "Today"
                            :time-grid t
                            :date today
                            :scheduled today
                            :order 1)))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-super-agenda-groups
                          '(
                            (:order-multi (1 (:name "Done today"
                                              :and (:regexp "State \"DONE\""
                                                    :log t))
                                             (:name "Clocked today"
                                              :log t)))
                            (:auto-group t
                             :order 10)
                            (:name "Next to do"
                             :todo "NEXT"
                             :order 2)
                            (:name "Due Today"
                             :deadline today
                             :order 3)
                            (:name "Important"
                             :tag "Important"
                             :priority "A"
                             :order 6)
                            (:name "Overdue"
                             :deadline past
                             :scheduled past
                             :face error
                             :order 7)
                            (:name "Due Soon"
                             :deadline future
                             :order 8)
                            (:name "Back Burner"
                             :order 10
                             :todo "SOMEDAY")))
                         (org-agenda-list)))))))

  :init
  (org-super-agenda-mode))
#+end_src

Evil binding are broken in ~org-super-agenda~.

#+begin_src emacs-lisp
(after! evil-org-agenda
  (setq org-super-agenda-header-map evil-org-agenda-mode-map))
#+end_src

*** ~org-modern~
/ü¶Ñ Modern Org Style/
**** Configuration

#+begin_quote
    Fontifying org-mode buffers to be as pretty as possible is of paramount
    importance, and Minad‚Äôs lovely org-modern goes a long way in this regard.

‚ÄïTecosaur
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! org-modern) ;; https://github.com/minad/org-modern
#+end_src

This is shamelessly stolen from Tecosaur's, I'll need to customize more to my
liking and remove the things I don't use.

#+begin_src emacs-lisp
(use-package! org-modern
  :hook (org-mode . global-org-modern-mode)
  :config
  (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
  (custom-set-faces! '(org-modern-statistics :inherit org-checkbox-statistics-todo))
  (setq
   org-modern-fold-stars '(("‚óê" . "‚óì") ("‚óë" . "‚óí") ("‚óê" . "‚óì"))
   org-modern-table-vertical 1
   org-modern-table-horizontal 0.2
   org-modern-footnote
   (cons nil (cadr org-script-display))
   org-modern-block-fringe nil
   org-modern-todo-faces
   '(("TODO"    :inverse-video t :inherit org-todo)
     ("[-]"     :inverse-video t :inherit +org-todo-active)
     ("[?]"     :inverse-video t :inherit +org-todo-onhold)
     ("NEXT"    :inverse-video t :inherit +org-todo-active)
     ("WAIT"    :inverse-video t :inherit +org-todo-onhold)
     ("REVIEW"  :inverse-video t :inherit +org-todo-onhold)
     ("HOLD"    :inverse-video t :inherit +org-todo-onhold)
     ("MAYBE"   :inverse-video t :inherit +org-todo-onhold)
     ("SOMEDAY" :inverse-video t :inherit +org-todo-onhold)
     ("NO"      :inverse-video t :inherit +org-todo-cancel)
     ("DROP"    :inverse-video t :inherit +org-todo-cancel))
   org-modern-block-name
   '((t . t)
     ("src"     "¬ª Ó™Ö" "¬´")
     ("example" "Û∞∂ª‚∏∫ " "Û∞∂∫")
     ("note" "¬ª Û∞éõ" "¬´")
     ("comment" "¬ª ÔÉ•" "¬´")
     ("quote"   "Û∞ùó" "Û∞âæ")
     ("export"  "‚è©" "‚è™"))
   ;; org-modern-progress nil
   org-modern-priority nil
   org-modern-horizontal-rule (make-string 36 ?‚îÄ)
   org-modern-keyword
   '((t                  . t)
     ("title"            . "ùôè")
     ("subtitle"         . "ùô©")
     ("author"           . "ùòº")
     ("email"            . "ÔêØ")
     ("date"             . "ùòø")
     ("property"         . "‚éà")
     ("options"          . #("Û∞òµ" 0 1 (display (height 0.75))))
     ("startup"          . "‚èª")
     ("macro"            . "ùìú")
     ("bind"             . "Û∞å∑")
     ("bibliography"     . "ÔêÖ")
     ("cite_export"      . "ÔêÖ‚Æ≠")
     ("glossary_sources" . "Û∞íª")
     ("include"          . "‚á§")
     ("setupfile"        . "‚áö")
     ("html_head"        . "üÖ∑")
     ("html"             . "üÖó")
     ("call"             . "Û∞úé")
     ("name"             . "‚Åç")
     ("header"           . "‚Ä∫")
     ("caption"          . "‚ò∞")
     ("results"          . "‚•±"))))
#+end_src

#+begin_src emacs-lisp
;; (add-to-list 'font-lock-extra-managed-props 'display)
;; (font-lock-add-keywords 'org-mode
;; `(("^.*?\\( \\)\\(:[[:alnum:]_@#%:]+:\\)$"
;; (1 `(face nil
;; display (space :align-to (- right ,(org-string-width (match-string 2)) 3)))
;; prepend))) t)
#+end_src

*** ~org-modern-indent~
/modern block styling with org-indent/
**** Configuration

Indenting headings in ~org-mode~ helps me find my way, so I was a bit sad when I
learned that it wasn't possible to see the nice block style with ~org-modern~.
~org-modern-indent~ to the rescue.

#+begin_src emacs-lisp :tangle packages.el
(package! org-modern-indent
  :recipe (:host github :repo "jdtsmith/org-modern-indent"))
#+end_src

#+begin_src  emacs-lisp
(use-package! org-modern-indent
  :defer t
  :after org-modern
  :hook
  (org-indent-mode . org-modern-indent-mode))
#+end_src

*** ~org-mouse~
**** Configuration

Sometimes it is nice to be able to use the mouse.

#+begin_src emacs-lisp
(require 'org-mouse)
#+end_src

*** FIXME ~org-gtd~
/A package for using GTD with org-mode/
**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! org-gtd) ;; https://github.com/Trevoke/org-gtd.el
#+end_src

#+begin_src emacs-lisp
(setq org-gtd-update-ack "3.0.0")
(use-package! org-gtd
  :demand t
  :after org
  :defer t

  :custom
  (org-gtd-directory org-directory)
  (org-gtd-areas-of-focus '("Home" "Personal" "Work" "Family" "Health" "Emacs" "NixOS" "YouTube" "Home-Assistant"))
  (org-agenda-property-list '("DELEGATED_TO"))
  (org-edna-use-inheritance t)

  :config
  (setq org-gtd-default-file-name "tasks.org")
  (org-edna-load)

  :init
  (map! :leader
        (:prefix ("z" . "org-gtd")
         :desc "Agenda"            "a" #'org-agenda
         :desc "Archive"           "A" #'org-gtd-archive-completed-items
         :desc "Capture"           "c" #'org-gtd-capture
         :desc "Clarify item"      "C" #'org-gtd-clarify-item
         :desc "Process inbox"     "i" #'org-gtd-process-inbox
         :desc "Organize"          "o" #'org-gtd-organize
         :desc "Engage"            "e" #'org-gtd-engage
         :desc "Engage"            "z" #'org-gtd-engage
         :desc "Show all next"     "n" #'org-gtd-show-all-next
         :desc "Stuck projects"    "s" #'org-gtd-review-stuck-projects
         :desc "Set area of focus" "f" #'org-gtd-area-of-focus-set-on-item-at-point
         :desc "Open tasks.org"    "t" (cmd! (find-file
                                              (expand-file-name "tasks.org" org-directory))))))

;; FIXME
(after! (evil org evil-org)
  (map!
   :after org-gtd
   :map org-gtd-clarify-map
   :desc "Organize" :m "o" #'org-gtd-organize
   (:prefix ("√ß" . "daf")
            "o" #'org-gtd-organize)))
#+end_src

*** ~org-appear~
/Toggle visibility of hidden Org mode element parts upon entering and leaving an
element/
**** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! org-appear) ;; https://github.com/awth13/org-appear
#+end_src

Add a hook to ~org-mode~.

#+begin_src emacs-lisp
(use-package! org-appear
  :commands (org-appear-mode)
  :hook     (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis   t   ;; Show bold, italics, verbatim, etc.
        org-appear-autolinks      t   ;; Show links
        org-appear-autosubmarkers t)) ;; Show sub- and superscripts

#+end_src

*** ~org-books~
/Reading list management with org mode/
**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! org-books) ;; https://github.com/lepisma/org-books
#+end_src

#+begin_src emacs-lisp
(use-package! org-books
  :defer t

  :config
  (setq org-books-file (expand-file-name "Perso/book.org" org-directory)))
#+end_src

*** FIXME ~org-capture~

#+BEGIN_SRC emacs-lisp
(after! org
  (defun transform-square-brackets-to-round-ones(string-to-transform)
    "Transforms [ into ( and ] into ), other chars left unchanged."
    (concat
     (mapcar #'(lambda (c) (if (equal c ?\[) ?\( (if (equal c ?\]) ?\) c))) string-to-transform)))

  (setq
   org-capture-templates
   `(
     ("i" "Inbox" entry  (file "inbox.org") ,(concat "* TODO %?\n"
                                                     "/Entered on/ %U"))
     ("p" "Project" entry (file "projects.org")
      "* %? [%] :project: \n:PROPERTIES: \n:TRIGGER: next-sibling todo!(NEXT) scheduled!(copy)\n:ORDERED: t \n:DATE_ADDED: %u\n:END:\n** Information :info:\n** Notes :notes:\n** Tasks :tasks:\n")
     ("x" "Protocol" entry (file+headline ,(concat org-directory "bookmarks.org") "Bookmarks")
      "** %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
     ("L" "Protocol Link" entry (file+headline ,(concat org-directory "bookmarks.org") "Bookmarks")
      "** %? [[%:link][%(transform-square-brackets-to-round-ones \"%:description\")]]\n")
     ("T" "Todo" entry (file+headline ,(concat org-directory "notes.org") "Inbox")
      "** [ ] %?\n")
     ("t" "Todo" entry (file+headline ,(concat org-directory "todo.org") "Inbox")
      "** [ ] %?\n"))))
#+END_SRC

*** ~org-noter~
/Emacs document annotator, using Org-mode/
**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! org-noter) ;; https://github.com/org-noter/org-noter
#+end_src

#+begin_src emacs-lisp
(use-package! org-noter
  :defer t)
#+end_src

*** ~org-now~
/Conveniently show current Org tasks in a sidebar window/
**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! org-now
  :recipe (:host github :repo "alphapapa/org-now")) ;; https://github.com/alphapapa/org-now
#+end_src

#+begin_src emacs-lisp
(use-package! org-now
  :defer t
  :custom
  (org-now-default-cycle-level 'nil)
  :hook (org-now . (lambda () (setq mode-line-format nil)))
  :hook (org-now . (lambda () (face-remap-add-relative 'org-level-1 '(:height 100))))
  :hook (org-now . (lambda () (face-remap-add-relative 'org-level-2 '(:height 120))))
  :hook (org-now . (lambda () (face-remap-add-relative 'org-level-3 '(:height 120))))

  :config
  (setq org-now-location (list (expand-file-name "tasks.org" org-directory) "Actions"))
  (set-popup-rules!
    '(("^\\*org-now"
       :actions (display-buffer-in-side-window)
       :slot 10 :vslot -1 :side right :size +popup-shrink-to-fit :quit nil)))
  :init
  (map!
   :prefix daf/localleader-key
   :n "n" #'org-now
   :n "√ß" #'org-now))
#+end_src

*** ~org-remark~
/Highlight & annotate text, EWW, Info, and EPUB/
**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! org-remark) ;; https://github.com/nobiot/org-remark
#+end_src

#+begin_src emacs-lisp
(use-package! org-remark
  :defer t
  :init
  (map! :g "C-c n m" #'org-remark-mark
        (:after org-remark
                (:map org-remap-mode-map
                      (:prefix "C-c n"
                       :g "o" #'org-remark-open
                       :g "]" #'org-remark-view-next
                       :g "[" #'org-remark-view-previous
                       :g "r" #'org-remark-remove)))))
#+end_src

*** ~org-roam~
/Rudimentary Roam replica with Org-mode/
**** Configuration

#+begin_src emacs-lisp
(after! org
  (setq org-roam-directory org-directory))
#+end_src

*** ~image-popup~
/Viewing image in org buffer is nice, but I'd rather have a small thumbnail with/
/a popup image, rather than configuring for every image its size./
**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! image-popup
  :recipe (:host gitlab :repo "OlMon/image-popup")) ;; https://gitlab.com/OlMon/image-popup
#+end_src

#+begin_src emacs-lisp
(use-package! image-popup
  :defer t
  :init
  (map!
   :map org-mode-map
   (:prefix ("√ß" . "daf")
    :n "i" #'image-popup-display-image-at-point)))
#+end_src

*** ~mermaid-mode~
**** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! ob-mermaid) ;; https://github.com/arnm/ob-mermaid
#+end_src

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((mermaid . t)
   (scheme  . t)))
#+end_src

*** ~spacious-mode~
/Increase the padding/spacing of GNU Emacs frames and windows./
**** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! spacious-padding) ;; https://github.com/protesilaos/spacious-padding
#+end_src

#+begin_src emacs-lisp
(use-package! spacious-padding
  :defer
  :hook (after-init . spacious-padding-mode))
#+end_src

*** ~denote~ Ó∏ï :ARCHIVE:

**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
;; (package! denote) ;; https://github.com/protesilaos/denote
#+end_src

#+begin_src emacs-lisp
;; (use-package! denote
;;   :defer t)
#+end_src

*** ~svg-tag-mode~ Ó∏ï :ARCHIVE:

/A minor mode for Emacs that replace keywords with nice SVG labels/

**** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! svg-tag-mode) ;; https://github.com/rougier/svg-tag-mode
#+end_src

#+begin_src emacs-lisp
;; (require 'svg-tag-mode)
;;
;; (defconst date-re "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}")
;; (defconst time-re "[0-9]\\{2\\}:[0-9]\\{2\\}")
;; (defconst day-re "[A-Za-z]\\{3\\}")
;; (defconst day-time-re (format "\\(%s\\)? ?\\(%s\\)?" day-re time-re))
;;
;; (defun svg-progress-percent (value)
;; (svg-image (svg-lib-concat
;; (svg-lib-progress-bar (/ (string-to-number value) 100.0)
;; nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
;; (svg-lib-tag (concat value "%")
;; nil :stroke 0 :margin 0)) :ascent 'center))
;;
;; (defun svg-progress-count (value)
;; (let* ((seq (mapcar #'string-to-number (split-string value "/")))
;; (count (float (car seq)))
;; (total (float (cadr seq))))
;; (svg-image (svg-lib-concat
;; (svg-lib-progress-bar (/ count total) nil
;; :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
;; (svg-lib-tag value nil
;; :stroke 0 :margin 0)) :ascent 'center)))
;;
;; (setq svg-tag-tags
;; `(
;; ;; Org tags
;; (":\\([A-Za-z0-9]+\\)" . ((lambda (tag) (svg-tag-make tag))))
;; (":\\([A-Za-z0-9]+[ \-]\\)" . ((lambda (tag) tag)))
;;
;; ;; Task priority
;; ("\\[#[A-Z]\\]" . ( (lambda (tag)
;; (svg-tag-make tag :face 'org-priority
;; :beg 2 :end -1 :margin 0))))
;;
;; ;; Progress
;; ("\\(\\[[0-9]\\{1,3\\}%\\]\\)" . ((lambda (tag)
;; (svg-progress-percent (substring tag 1 -2)))))
;; ("\\(\\[[0-9]+/[0-9]+\\]\\)" . ((lambda (tag)
;; (svg-progress-count (substring tag 1 -1)))))
;;
;; ;; TODO / DONE
;; ("TODO" . ((lambda (tag) (svg-tag-make "TODO" :face 'org-todo :inverse t :margin 0))))
;; ("DONE" . ((lambda (tag) (svg-tag-make "DONE" :face 'org-done :margin 0))))
;;
;;
;; ;; Citation of the form [cite:@Knuth:1984]
;; ("\\(\\[cite:@[A-Za-z]+:\\)" . ((lambda (tag)
;; (svg-tag-make tag
;; :inverse t
;; :beg 7 :end -1
;; :crop-right t))))
;; ("\\[cite:@[A-Za-z]+:\\([0-9]+\\]\\)" . ((lambda (tag)
;; (svg-tag-make tag
;; :end -1
;; :crop-left t))))
;;
;;
;; ;; Active date (with or without day name, with or without time)
;; (,(format "\\(<%s>\\)" date-re) .
;; ((lambda (tag)
;; (svg-tag-make tag :beg 1 :end -1 :margin 0))))
;; (,(format "\\(<%s \\)%s>" date-re day-time-re) .
;; ((lambda (tag)
;; (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0))))
;; (,(format "<%s \\(%s>\\)" date-re day-time-re) .
;; ((lambda (tag)
;; (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0))))
;;
;; ;; Inactive date  (with or without day name, with or without time)
;; (,(format "\\(\\[%s\\]\\)" date-re) .
;; ((lambda (tag)
;; (svg-tag-make tag :beg 1 :end -1 :margin 0 :face 'org-date))))
;; (,(format "\\(\\[%s \\)%s\\]" date-re day-time-re) .
;; ((lambda (tag)
;; (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0 :face 'org-date))))
;; (,(format "\\[%s \\(%s\\]\\)" date-re day-time-re) .
;; ((lambda (tag)
;; (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0 :face 'org-date))))))
#+end_src

-----
* Level 5: Phobos Lab ¬∑ /Packages/

/Next up, configuration for packages _not_ managed by ~Doom~./

** ~affe~
/üêí affe.el - Asynchronous Fuzzy Finder for Emacs/
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! affe) ;; https://github.com/minad/affe
#+end_src

#+begin_src emacs-lisp
(use-package! affe
  :after orderless
  :config
  ;; We always want hidden files and we don't really want to search inside the
  ;; git blobs or the syncthing versions
  (let ((base "rg --color=never --hidden --glob !*.git/ --glob !*.stversions/"))
    (setq affe-find-command (format "%s --files" base))
    (setq affe-dir-command "fd --color=never --type directory")
    (setq affe-grep-command (format "%s --null --max-columns=1000 --no-heading --line-number -v ^$ ." base)))

  ;; Configure Orderless
  (setq affe-regexp-function #'orderless-pattern-compiler)
  (setq affe-highlight-function #'orderless-highlight-matches)

  ;; Manual preview key for `affe-grep'
  (consult-customize affe-grep :preview-key (kbd "M-.")))
#+end_src

** ~avy~
/Jump to things in Emacs tree-style/
*** Configuration & Mapping

[[https://karthinks.com/software/avy-can-do-anything/][Avy can do anything.]]

- /He delet/

#+begin_src emacs-lisp
(defun daf/avy-action-kill-whole-line (pt)
  (save-excursion
    (goto-char pt)
    (kill-whole-line))
  (select-window
   (cdr
    (ring-ref avy-ring 0)))
  t)

(after! avy
  (setf (alist-get ?d avy-dispatch-alist) 'avy-action-kill-stay
        (alist-get ?D avy-dispatch-alist) 'daf/avy-action-kill-whole-line))
#+end_src

- /He duplicat/

#+begin_src emacs-lisp
(defun daf/avy-action-copy-whole-line (pt)
  (save-excursion
    (goto-char pt)
    (cl-destructuring-bind (start . end)
        (bounds-of-thing-at-point 'line)
      (copy-region-as-kill start end)))
  (select-window
   (cdr
    (ring-ref avy-ring 0)))
  t)

(defun daf/avy-action-yank-whole-line (pt)
  (daf/avy-action-copy-whole-line pt)
  (save-excursion (yank))
  t)

(after! avy
  (setf (alist-get ?y avy-dispatch-alist) 'avy-action-yank
        (alist-get ?w avy-dispatch-alist) 'avy-action-copy
        (alist-get ?W avy-dispatch-alist) 'daf/avy-action-copy-whole-line
        (alist-get ?Y avy-dispatch-alist) 'daf/avy-action-yank-whole-line))
#+end_src

- /He teleport/

#+begin_src emacs-lisp
(defun daf/avy-action-teleport-whole-line (pt)
  (daf/avy-action-kill-whole-line pt)
  (save-excursion (yank)) t)

(after! avy
  (setf (alist-get ?m avy-dispatch-alist) 'avy-action-teleport
        (alist-get ?M avy-dispatch-alist) 'daf/avy-action-teleport-whole-line))
#+end_src

- /He embark/

#+begin_src emacs-lisp
(defun daf/avy-action-embark (pt)
  (unwind-protect
      (save-excursion
        (goto-char pt)
        (embark-act))
    (select-window
     (cdr (ring-ref avy-ring 0))))
  t)

(after! avy
  (setf (alist-get ?. avy-dispatch-alist) 'daf/avy-action-embark))
#+end_src

** ~blamer~ ¬∑ Who wrote that crap!? (probably me.)
/Get git commit info at a glance./

I sometimes need to quickly know who made a modification, ~blamer.el~ helps me by
showing commit information at a glance.

*** TODO Overview
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! blamer) ;; https://github.com/Artawower/blamer.el
#+end_src

Let's customize the face and add a few key bindings.

#+begin_src emacs-lisp
(use-package! blamer
  :defer
  :custom
  (blamer-idle-time 0.3)
  (blamer-min-offset 70)
  :custom-face
  (blamer-face ((t :foreground "#7a88cf"
                   :background unspecified
                   :italic t)))
  :init
  (map!
   :leader
   (:prefix ("g" . "git")
    :desc  "Blamer posframe commit info" "," #'blamer-show-posframe-commit-info
    :desc  "Blamer mode"                 ";" #'blamer-mode)))
#+end_src

** ~circadian~ ¬∑ Cadia Stands!!!
/But only until 19h30, after that: _lights out_./
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! circadian) ;; https://github.com/guidoschmidt/circadian.el
#+end_src

#+begin_src emacs-lisp
(use-package! circadian
  :init
  (add-hook 'circadian-after-load-theme-hook
            #'(lambda (theme)
                (message "Setting circadian theme.")
                (cond ((eq doom-theme daf/dark-theme)
                       (message "Setting dark modeline theme."))
                      ((eq doom-theme daf/light-theme)
                       (message "Setting light modeline theme.")))
                (doom/reload-theme)))

  :config
  (setq circadian-themes `(("7:30" . ,daf/light-theme)
                           ("19:30" . ,daf/dark-theme)))
  (circadian-setup))

#+end_src

** ~ef-themes~ ¬∑ Œµ·Ωñ pour les intimes
/Collection of themes./
*** Configuration & Mapping

Prot's at it again with another great package and great themes.

#+begin_src emacs-lisp :tangle packages.el
(package! ef-themes) ;; https://github.com/protesilaos/ef-themes
#+end_src

We want our ~org~ headings to be of different size to be more distinguishable.

#+begin_src emacs-lisp
(use-package! ef-themes
  :defer t

  :config
  (setq ef-themes-bold-constructs   t
        ef-themes-italic-constructs t
        ef-themes-mixed-fonts       t
        ef-themes-variable-pitch-ui t))
#+end_src

** ~embrace~ ¬∑ ü´Ç
/Add/Change/Delete pairs based on `expand-region', similar to `evil-surround'./
*** Overview

|------------+-------------------+-------------|
| Keybind(s) | Emacs Command     | Description |
|------------+-------------------+-------------|
| =, e=        | Embrace prefix    |             |
| =, e e=      | ~embrace-commander~ | Commander   |
| =, e a=      | ~embrace-add~       | Add         |
| =, e c=      | ~embrace-change~    | Change      |
| =, e d=      | ~embrace-delete~    | Delete      |
|------------+-------------------+-------------|
*** Configuration

#+begin_src emacs-lisp
(use-package! embrace
  :defer t

  :init
  (map!
   (:prefix ("," . "daf")
            (:prefix ("e" . "embrace")
             :desc "Commander" :nv  "e" #'embrace-commander
             :desc "Add"       :nv  "a" #'embrace-add
             :desc "Change"    :nv  "c" #'embrace-change
             :desc "Delete"    :nv  "d" #'embrace-delete)))

  :config
  (after! evil-embrace
    (setq evil-embrace-show-help-p t))
  (setq embrace-show-help-p t))

#+end_src

** ~focus~ ¬∑ But I can't!! I must conf Emacs!
/A package to dim everything that is not in focus./
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! focus) ;; https://github.com/larstvei/Focus
#+end_src
** ~grugru~ ¬∑ Death by ~grugru~
/Rotate text at point in Emacs./
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! grugru) ;; https://github.com/ROCKTAKEY/grugru
#+end_src

#+begin_src emacs-lisp
(use-package! grugru
  :config
  (grugru-highlight-mode)
  (grugru-default-setup)

  :init
  (map!
   (:prefix ("√ß" . "daf")
    :desc "Rotate text" :n "√ß" #'grugru
    :desc "Rotate text" :n "r" #'grugru)))
#+end_src

** ~indent-bars~ ¬∑ If Emacs is a prison, at least the bars are nice
/Fast, configurable indentation guide-bars for Emacs/
*** Overview

|------------+------------------+--------------------|
| Keybind(s) | Emacs Command    | Description        |
|------------+------------------+--------------------|
| =SPC t i=    | ~indent-bars-mode~ | Toggle indent bars |
|            |                  |                    |
|------------+------------------+--------------------|
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! indent-bars
  :recipe (:host github :repo "jdtsmith/indent-bars")) ;; https://github.com/jdtsmith/indent-bars
#+end_src

#+begin_src emacs-lisp
(use-package! indent-bars
  :custom
  (indent-bars-treesit-support t)
  (indent-bars-treesit-ignore-blank-lines-types '("module"))

  :hook (prog-mode . indent-bars-mode)

  :init
  (map! :leader
        (:prefix ("t" . "toggle")
         :desc "Indent Bars" :mvn "i" #'indent-bars-mode)))
#+end_src

** ~info-colors~
/Extra colors for Emacs's Info-mode/
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! info-colors) ;; https://github.com/ubolonton/info-colors
#+end_src

#+begin_src emacs-lisp
(use-package! info-colors
  :hook (Info-selection . info-colors-fontify-node))
#+end_src

** ~jinx~
/ü™Ñ Enchanted Spell Checker/
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! jinx) ;; https://github.com/minad/jinx
#+end_src

#+begin_src emacs-lisp
(use-package! jinx
  :defer t

  :init
  (add-hook 'doom-init-ui-hook #'global-jinx-mode)
  (map!
   :leader
   (:prefix ("t" . "toggle")
    :desc "Spell checker"  "s"  #'jinx-mode))

  :config
  ;; Use my custom dictionary
  (setq jinx-languages "en fr"
        global-jinx-modes '(text-mode conf-mode))
  ;; Extra face(s) to ignore
  (push 'org-inline-src-block
        (alist-get 'org-mode jinx-exclude-faces))
  ;; Take over the relevant bindings.
  (after! ispell
    (global-set-key [remap ispell-word] #'jinx-correct))
  (after! evil-commands
    (global-set-key [remap evil-next-flyspell-error] #'jinx-next)
    (global-set-key [remap evil-prev-flyspell-error] #'jinx-previous))
  ;; I prefer for `point' to end up at the start of the word,
  ;; not just after the end.
  (advice-add 'jinx-next :after (lambda (_) (left-word))))
#+end_src

** ~jq-mode~
/Interactively parse JSON in Emacs./
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! jq-mode) ;; https://github.com/ljos/jq-mode
#+end_src

** ~languagetool~ ¬∑ Squiggly line my prose
/Grammar correction./

~Doom~ ship ~Emacs-langtool~ but I prefer ~languagetool.el~, let's set it up.

**** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! languagetool) ;; https://github.com/PillFall/languagetool.el
#+end_src

~languagetool~ being a Java program, it needs to be shown the way to its .jar,
Let's obliged.

#+begin_src emacs-lisp
(use-package! languagetool
  :defer t

  :config
  (setq languagetool-java-arguments '("-Dfile.encoding=UTF-8")
        languagetool-correction-language "en-US"  ;; 'auto' seems to target "en", which isn't working as well as 'en-US'
        languagetool-console-command "/etc/profiles/per-user/daf/share/languagetool-commandline.jar"
        languagetool-server-command "/etc/profiles/per-user/daf/share/languagetool-server.jar")

  :init
  (map!
   (:prefix ("z~" . "languagetool")
    :desc "Correct buffer"   :n "b" #'languagetool-correct-buffer
    :desc "Correct at point" :n "c" #'languagetool-correct-at-point
    :desc "Set language"     :n "l" #'(lambda ()
                                        (interactive)
                                        (languagetool-set-language
                                         (completing-read "lang: " '("fr" "en-US"))))
    :n "~" #'languagetool-check)))
#+end_src

** ~litable~
/On-the-fly evaluation/substitution of emacs lisp code/
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! litable
  :recipe (:host github :repo "Fuco1/litable")) ;; https://github.com/Fuco1/litable
#+end_src

#+begin_src emacs-lisp
(use-package! litable
  :custom
  (litable-list-file (expand-file-name "litable-lists.el" doom-cache-dir))
  :init
  (map! :localleader
        :map emacs-lisp-mode-map
        "l" #'litable-mode))
#+end_src

** ~logos~ ¬∑ Hocus Pocus, Logus Focus
/Navigate documents by jumping to pages/outlines./
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! logos) ;; https://github.com/protesilaos/logos
#+end_src

#+begin_src emacs-lisp
(use-package! logos
  :defer t

  :hook (logos-focus-mode . (lambda () (olivetti-mode 1)))

  :config
  (setq logos-outline-regexp-alist
        `((emacs-lisp-mode . ,(format "\\(^;;;+ \\|%s\\)" logos--page-delimiter))
          (org-mode . ,(format "\\(^\\*\\{1,3\\} +\\|^-\\{5\\}$\\|%s\\)" logos--page-delimiter))))

  ;; These apply when `logos-focus-mode' is enabled.  Their value is
  ;; buffer-local.
  (setq-default logos-hide-cursor            nil
                logos-hide-mode-line         nil
                logos-hide-buffer-boundaries t
                logos-outlines-are-pages     t
                logos-hide-fringe            t
                logos-variable-pitch         t
                logos-buffer-read-only       nil
                logos-scroll-lock            nil
                logos-olivetti               t)

  :init
  (map! :leader
        (:prefix "t"
         :desc "Logos" "L" #'logos-focus-mode)))
#+end_src

** ~mlscroll~
/Lightweight scrollbar for the Emacs mode line/
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! mlscroll) ;; https://github.com/jdtsmith/mlscroll
#+end_src

#+begin_src emacs-lisp
(use-package! mlscroll
  :config
  (mlscroll-mode 1)

  :init
  (setq mlscroll-right-align t))

(after! doom-modeline
  (doom-modeline-def-modeline 'main
    '(eldoc bar workspace-name window-number modals matches follow buffer-info remote-host word-count parrot selection-info)
    '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus github debug repl lsp minor-modes input-method indent-info buffer-encoding major-mode process vcs check buffer-position time)))
#+end_src

** ~modus-themes~ ¬∑ My modus operandi? Impeccable theme
/Two highly readable themes./
*** Configuration

The ~modus-themes~ are builtin to Emacs, they are that great! But I want the
latest version possible.

#+begin_src emacs-lisp :tangle packages.el
(package! modus-themes) ;; https://github.com/protesilaos/modus-themes
#+end_src

Also, let's set it up in a similar fashion that we did with ~ef-themes~.

#+begin_src emacs-lisp
(use-package! modus-themes
  :init
  (setq modus-themes-bold-constructs   t
        modus-themes-italic-constructs t
        modus-themes-mixed-fonts       t
        modus-themes-variable-pitch-ui t))
#+end_src

** ~nov~ ¬∑ ¬´ 'Cause nothin' lasts forever, even cold ~Nov~ ember rain ¬ª Û∞éá
/Ebook reader in Emacs./
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! nov) ;; https://depp.brause.cc/nov.el/
#+end_src

#+begin_src emacs-lisp
(use-package! nov
  :defer t

  :mode ("\\.epub\\'" . nov-mode)

  :hook (nov-mode . mixed-pitch-mode)
  :hook (nov-mode . visual-line-mode)
  :hook (nov-mode . visual-fill-column-mode)
  :hook (nov-mode . hide-mode-line-mode)
  :hook (nov-mode . (lambda () (hl-line-mode -1)))
  :hook (nov-mode . (lambda () (set (make-local-variable 'scroll-margin) 1)))
  :hook (nov-mode . daf/nov-font-setup)

  :config
  (setq nov-text-width t
        nov-variable-pitch t
        visual-fill-column-center-text t)

  :init
  (map!
   :after nov
   :map nov-mode-map
   :n "T"     #'daf/scroll-bottom-line-to-top
   :n [down]  #'daf/scroll-bottom-line-to-top
   :n [right] #'daf/scroll-bottom-line-to-top
   :n "S"     #'daf/scroll-top-line-to-bottom
   :n [up]    #'daf/scroll-top-line-to-bottom
   :n [left]  #'daf/scroll-top-line-to-bottom))
#+end_src

I want a nice comfy font when reading e-books.

#+begin_src emacs-lisp
(defun daf/nov-font-setup ()
  "Sets a specific font for 'nov'."
  (set (make-local-variable 'buffer-face-mode-face)
       '(:family "Literata" :height 1.2))
  (face-remap-add-relative 'fixed-pitch)
  (buffer-face-mode t))
#+end_src

** ~nushell~
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! nushell-ts-mode
  :recipe (:host github :repo "herbertjones/nushell-ts-mode")) ;; https://github.com/herbertjones/nushell-ts-mode
#+end_src

** ~obvious~ ¬∑ ¬´ Couvrez ce commentaire, que je ne saurais voir ¬ª
/Who needs comments when the code is so obvious/
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! obvious
  :recipe (:host github :repo "alphapapa/obvious.el")) ;; https://github.com/alphapapa/obvious.el
#+end_src

#+begin_src emacs-lisp
(map!
 :leader (:prefix ("t" . "toggle")
          :desc "Obvious" "O" #'obvious-mode))
#+end_src

** ~olivetti~ ¬∑ ü´í Olive et +Tom+ Tim
                            /Center buffer content./
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! olivetti) ;; https://github.com/rnkn/olivetti
#+end_src

#+begin_src emacs-lisp
(use-package! olivetti
  :defer t
  :custom
  (olivetti-body-width 0.6)
  :config
  (setq olivetti-style 'fancy)
  (setq olivetti-minimum-body-width 80)
  :init
  (map! :leader
        (:prefix "t"
         :desc "Olivetti" "o" #'olivetti-mode)))
#+end_src

** ~paren-face~
/A face dedicated to lisp parentheses/
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! paren-face) ;; https://github.com/tarsius/paren-face
#+end_src

#+begin_src emacs-lisp
(use-package! paren-face
  :config
  (global-paren-face-mode 1))
#+end_src

** ~puni~ ¬∑ Structural editing for the puni humans
/Structured editing √† la ~ParEdit~ / ~Lispy~ for a bunch of languages./
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! puni) ;; https://github.com/AmaiKinono/puni
#+end_src

An improved version of ~puni-kill-line~, from the repo's wiki.

#+begin_src emacs-lisp
;;;###autoload
(defun daf/puni-kill-line ()
  "Kill a line forward while keeping expressions balanced.
If nothing can be deleted, kill backward. If still nothing can be
deleted, kill the pairs around point."
  (interactive)
  (let ((bounds (puni-bounds-of-list-around-point)))
    (if (eq (car bounds) (cdr bounds))
        (when-let ((sexp-bounds (puni-bounds-of-sexp-around-point)))
          (puni-delete-region (car sexp-bounds) (cdr sexp-bounds) 'kill))
      (if (eq (point) (cdr bounds))
          (puni-backward-kill-line)
        (puni-kill-line)))))

#+end_src

I want to be able to insert a new line at the end of a /sexp/.

#+begin_src emacs-lisp
(defun daf/open-end-of-sexp ()
  "Go to end of sexp and insert newline."
  (interactive)
  (puni-end-of-sexp)
  (newline-and-indent)
  (evil-insert 1))
#+end_src

#+begin_src emacs-lisp
(use-package! puni
  :init
  (map!
   :map puni-mode-map
   (:prefix ("," . "daf")
    :nv "o"   #'daf/open-end-of-sexp
    :nv "v"   #'puni-expand-region
    :nv "V"   #'puni-contract-region
    :nv "s"   #'puni-squeeze
    :nv "/"   #'puni-split
    :nv "S"   #'puni-splice
    :nv "r"   #'puni-raise
    :nv "t"   #'puni-transpose
    (:prefix ("w"  . "wrap")
     :nv "p" #'puni-wrap-round
     :nv "(" #'puni-wrap-round
     :nv "b" #'puni-wrap-square
     :nv "[" #'puni-wrap-square
     :nv "c" #'puni-wrap-curly
     :nv "{" #'puni-wrap-curly
     :nv "a" #'puni-wrap-angle
     :nv "¬´" #'puni-wrap-angle)
    :nv "d" #'daf/puni-kill-line
    :nv "D" #'puni-backward-kill-line
    :nv "C" #'puni-convolute
    :nv "p" #'puni-backward-sexp-or-up-list
    :nv "P" #'puni-beginning-of-sexp
    :nv "n" #'puni-forward-sexp-or-up-list
    :nv "N" #'puni-end-of-sexp
    :nv "<" #'puni-slurp-backward
    :nv ">" #'puni-slurp-forward
    :nv "¬´" #'puni-slurp-backward
    :nv "¬ª" #'puni-slurp-forward))
  ;; The autoloads of Puni are set up so you can enable `puni-mode` or
  ;; `puni-global-mode` before `puni` is actually loaded. Only after you press
  ;; any key that calls Puni commands, it's loaded.
  (puni-global-mode)
  (add-hook 'term-mode-hook #'puni-disable-puni-mode))
#+end_src

** ~pulsar~
/Emacs package to pulse the current line after running select functions./
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! pulsar) ;; https://github.com/protesilaos/pulsar
#+end_src

#+begin_src emacs-lisp
(use-package! pulsar
  :defer t
  :config
  (add-to-list 'pulsar-pulse-functions 'evil-scroll-up)
  (add-to-list 'pulsar-pulse-functions 'evil-scroll-down)
  (add-to-list 'pulsar-pulse-functions 'evil-ex-search-next)
  (add-to-list 'pulsar-pulse-functions 'evil-ex-search-previous)
  (setopt pulsar-pulse t
          pulsar-delay 0.055
          pulsar-iterations 10
          pulsar-face 'pulsar-magenta
          pulsar-highlight-face 'pulsar-cyan)
  (custom-set-faces!
    `(pulsar-magenta :background ,everforest-hard-dark-purple))
  (pulsar-global-mode 1)
  :init
  (map!
   :leader
   (:prefix ("t" . "toggle")
    :desc "Pulse line" "." #'pulsar-pulse-line))
  :hook
  ((next-error . (pulsar-pulse-line-red pulsar-recenter-top pulsar-reveal-entry))
   (minibuffer-setup . pulsar-pulse-line-red)))
#+end_src

** ~rainbow-mode~ ¬∑ üåà Allez les #002654
*** Configuration & Mapping

#+begin_src emacs-lisp
(use-package! rainbow-mode
  :hook prog-mode
  :init
  (map!
   :leader (:prefix ("t" . "toggle")
            :desc "Rainbow mode"  "R" #'rainbow-mode)))
#+end_src

** ~rotate~ ¬∑ Spin me right round
/Rotate windows' layout./
*** Configuration & Mapping

A nice little package which allows to rotate layout.

#+begin_src emacs-lisp :tangle packages.el
(package! rotate) ;; https://github.com/daichirata/emacs-rotate
#+end_src

#+begin_src emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout)
#+end_src

** TODO ~tempel~
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! tempel) ;; https://github.com/minad/tempel
(package! tempel-collection) ;; https://github.com/Crandel/tempel-collection

#+end_src

#+begin_src emacs-lisp
(use-package! tempel
  ;; Require trigger prefix before template name when completing.
  ;; :custom
  ;; (tempel-trigger-prefix "<")

  :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
         ("M-*" . tempel-insert))

  :init

  ;; Setup completion at point
  (defun daf/tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions'.
    ;; `tempel-expand' only triggers on exact matches. Alternatively use
    ;; `tempel-complete' if you want to see all matches, but then you
    ;; should also configure `tempel-trigger-prefix', such that Tempel
    ;; does not trigger too often when you don't expect it. NOTE: We add
    ;; `tempel-expand' *before* the main programming mode Capf, such
    ;; that it will be tried first.
    (setq-local completion-at-point-functions
                (cons #'tempel-expand
                      completion-at-point-functions)))

  (add-hook 'conf-mode-hook 'daf/tempel-setup-capf)
  (add-hook 'prog-mode-hook 'daf/tempel-setup-capf)
  (add-hook 'text-mode-hook 'daf/tempel-setup-capf)

  (setq tempel-path (expand-file-name "templates/*" doom-user-dir))

  ;; Optionally make the Tempel templates available to Abbrev,
  ;; either locally or globally. `expand-abbrev' is bound to C-x '.
  ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
  ;; (global-tempel-abbrev-mode)
  )

;; Optional: Add tempel-collection.
;; The package is young and doesn't have comprehensive coverage.
(use-package! tempel-collection)
#+end_src

** ~verb~
/Send HTTP requests in ~org-mode~./
*** TODO Overview
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! verb) ;; https://github.com/federicotdn/verb
#+end_src

#+begin_src emacs-lisp
(use-package! verb
  :defer t

  :config
  (setq verb-json-use-mode 'json-mode)

  (defun daf/graphql-to-json (rs)
    ;; Modify RS and return it (RS is a request specification, type `verb-request-spec')
    (oset rs body
          (replace-regexp-in-string "\n" ""
                                    (format-message "{\"query\": \"%s\"}"
                                                    (oref rs body))))
    rs)

  :init
  (map! :leader
        (:prefix ("v" . "verb")
         :map verb-mode-map
         :desc "send request"              "V" #'verb-send-request-on-point-other-window
         :desc "send request other window" "v" #'verb-send-request-on-point-other-window-stay
         :desc "re-send request"           "r" #'verb-re-send-request
         :desc "export curl request"       "c" #'verb-export-request-on-point-curl
         (:prefix ("h" . "verb help")
          :desc "show sent request"        "r" #'verb-show-request
          :desc "show headers"             "h" #'verb-toggle-show-headers
          :desc "show vars"                "v" #'verb-show-vars
          :desc "show logs"                "l" #'verb-show-log
          :desc "set var"                  "s" #'verb-set-var
          :desc "unset vars"               "u" #'verb-unset-vars))))

(set-popup-rules!
  '(("^\\*HTTP Response.*" :quit t :side right :size 0.4 :modeline nil)))
#+end_src

** ~vundo~
/Show undos in a tree./
**** Configuration & Mapping

#+begin_src emacs-lisp
(use-package! vundo
  :defer t
  :init
  (evil-define-key* 'normal 'global "U" #'vundo))
#+end_src

** ~zoom~
/Fixed and automatic balanced window layout for Emacs/
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
(package! zoom) ;; https://github.com/cyrus-and/zoom
#+end_src

Disabled by default, =SPC t == to enable it. This is mainly because, there's a bug
with popup shell.

#+begin_src emacs-lisp
(use-package! zoom
  :defer t
  ;; :hook (doom-first-input . zoom-mode)

  :init
  (map! :leader
        (:prefix ("t" . "toggle")
         :desc "Zoom mode" "=" #'zoom-mode))
  (setq zoom-mode nil)

  :config
  (setq zoom-size '(0.7 . 0.7)
        zoom-ignored-major-modes         '(dired-mode vterm-mode help-mode
                                           helpful-mode rxt-help-mode
                                           help-mode-menu org-mode)
        zoom-ignored-buffer-names        '("*doom:scratch*" "*info*"
                                           "*helpful variable: argv*")
        zoom-ignored-buffer-name-regexps '("^\\*calc" "\\*helpful variable: .*\\*")))
#+end_src

** ~todoist~ Ó∏ï  :ARCHIVE:
/Emacs interface to todoist/
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
;; (package! todoist) ;; https://github.com/abrochard/emacs-todoist
#+end_src

** ~elogcat~ Ó∏ï :ARCHIVE:
/Manage Android logs./

Occasionally (only happen once to be honest), I need to debug an Android app,
~elogcat~ allows me to get cleaner logs.

*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
;; (package! elogcat) ;; https://github.com/youngker/elogcat.el
#+end_src

I wrote some ugly function to add filters to ~logcat~.

#+begin_src emacs-lisp
;; (use-package! elogcat
;;   :defer t
;;   :config
;;   (defun daf/elogcat-set-tail ()
;;     "Add a limit of line to the command"
;;     (interactive)
;;     (setq elogcat-logcat-command (concat elogcat-logcat-command " -T 50")))

;;   (defun daf/elogcat-set-include-filter-pid ()
;;     "Try to determine a PID from an input, and set it as a filter"
;;     (interactive)
;;     (elogcat-set-include-filter (substring
;;                                  (shell-command-to-string
;;                                   (format "adb shell ps | grep -F %s | tr -s '[:space:]' ' ' | cut -d' ' -f2" (read-string "app namespace: ")))
;;                                  0 -1)))
;;   :init
;;   (map! :map elogcat-mode-map
;;         :localleader
;;         "i" #'elogcat-set-include-filter
;;         "I" #'elogcat-clear-include-filter
;;         "x" #'elogcat-set-exclude-filter
;;         "X" #'elogcat-clear-exclude-filter
;;         "p" #'daf/elogcat-set-include-filter-pid
;;         "t" #'daf/elogcat-set-tail
;;         "g" #'elogcat-show-status
;;         "m" #'elogcat-toggle-main
;;         "s" #'elogcat-toggle-system
;;         "e" #'elogcat-toggle-events
;;         "r" #'elogcat-toggle-radio
;;         "k" #'elogcat-toggle-kernel
;;         "c" #'elogcat-erase-buffer))
#+end_src
** ~fontaine~ Ó∏ï ¬∑ Ma√Ætre Corbeau, sur un arbre perch√© :ARCHIVE:
/Faces preset./
/The Quick Brown Fox Jumps Over The Lazy Dog/
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
;; (package! fontaine) ;; https://github.com/protesilaos/fontaine
#+end_src

And now, for the configuration, which is largely copied from the repo's
instruction.

#+begin_src emacs-lisp
;; (use-package! fontaine
;;   :config

;;   ;; Iosevka Comfy is my highly customised build of Iosevka with
;;   ;; monospaced and duospaced (quasi-proportional) variants as well as
;;   ;; support or no support for ligatures:
;;   ;; <https://git.sr.ht/~protesilaos/iosevka-comfy>.
;;   ;;
;;   ;; Iosevka Comfy            == monospaced, supports ligatures
;;   ;; Iosevka Comfy Fixed      == monospaced, no ligatures
;;   ;; Iosevka Comfy Duo        == quasi-proportional, supports ligatures
;;   ;; Iosevka Comfy Wide       == like Iosevka Comfy, but wider
;;   ;; Iosevka Comfy Wide Fixed == like Iosevka Comfy Fixed, but wider
;;   ;; Iosevka Comfy Motion     == monospaced, supports ligatures, fancier glyphs
;;   ;; Iosevka Comfy Motion Duo == as above, but quasi-proportional
;;   (setq fontaine-presets
;;         '((smaller
;;            :default-family "Iosevka Comfy Wide Fixed"
;;            :default-height 90
;;            :variable-pitch-family "Iosevka Comfy Wide Duo")
;;           (small
;;            :default-family "Iosevka Comfy Wide Fixed"
;;            :default-height 100
;;            :variable-pitch-family "Iosevka Comfy Wide Duo")
;;           (regular
;;            :default-height 120)
;;           (large
;;            :default-weight semilight
;;            :default-height 150
;;            :bold-weight extrabold)
;;           (larger
;;            :default-weight semilight
;;            :default-height 160
;;            :bold-weight extrabold)
;;           (code-demo
;;            :default-family "Iosevka Comfy Fixed"
;;            :default-weight semilight
;;            :default-height 190
;;            :variable-pitch-family "Iosevka Comfy Duo"
;;            :bold-weight extrabold)
;;           (presentation
;;            :default-weight semilight
;;            :default-height 220
;;            :bold-weight extrabold)
;;           (legally-blind
;;            :default-weight semilight
;;            :default-height 260
;;            :bold-weight extrabold)
;;           (merriweather
;;            :default-family "Merriweather"
;;            :variable-pitch-family "Merriweather"
;;            :default-height 150)
;;           (iosevka-nerd-font
;;            :default-family "Iosevka Nerd Font")
;;           (sarasa
;;            :default-family "Sarasa Term J"
;;            :variable-pitch-family "Sarasa Term Slab TC")
;;           (ibm-plex-sans
;;            :default-family "IBM Plex Sans")
;;           (ibm-plex-mono
;;            :default-family "IBM Plex Mono")
;;           (t
;;            ;; I keep all properties for didactic purposes, but most can be
;;            ;; omitted.  See the fontaine manual for the technicalities:
;;            ;; <https://protesilaos.com/emacs/fontaine>.
;;            :default-family "Iosevka Comfy"
;;            :default-weight regular
;;            :default-height 120
;;            :fixed-pitch-family nil      ; falls back to :default-family
;;            :fixed-pitch-weight nil      ; falls back to :default-weight
;;            :fixed-pitch-height 1.0
;;            :fixed-pitch-serif-family nil ; falls back to :default-family
;;            :fixed-pitch-serif-weight nil ; falls back to :default-weight
;;            :fixed-pitch-serif-height 1.0
;;            :variable-pitch-family "Iosevka Comfy Motion Duo"
;;            :variable-pitch-weight nil
;;            :variable-pitch-height 1.0
;;            :bold-family nil             ; use whatever the underlying face has
;;            :bold-weight bold
;;            :italic-family nil
;;            :italic-slant italic
;;            :line-spacing nil)))

;;   ;; Set last preset or fall back to desired style from `fontaine-presets'.
;;   (fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular))

;;   ;; The other side of `fontaine-restore-latest-preset'.
;;   (add-hook 'kill-emacs-hook #'fontaine-store-latest-preset)

;;   ;; Persist font configurations while switching themes (doing it with
;;   ;; my `modus-themes' and `ef-themes' via the hooks they provide).
;;   (dolist (hook '(modus-themes-after-load-theme-hook ef-themes-post-load-hook))
;;     (add-hook hook #'fontaine-apply-current-preset))

;;   :init
;;   (map! :leader
;;         (:prefix ("√ß" . "daf")
;;                      "F" #'fontaine-set-face-font
;;                      "f" #'fontaine-set-preset)))
#+end_src

** ~golden-ratio~ Ó∏ï :ARCHIVE:
/Automatic resizing of Emacs windows to the golden ratio./
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
;; (package! golden-ratio) ;; https://github.com/roman/golden-ratio.el
#+end_src

#+begin_src emacs-lisp
;; (use-package! golden-ratio
;; :after-call pre-command-hook
;; :hook doom-switch-window-hook
;; :init
;; (map! :leader
;; (:prefix ("w" . "windows")
;; :desc "Toggle golden-ratio mode" "g" #'golden-ratio-mode))
;;
;; :config
;; (golden-ratio-mode +1)
;; ;; Using this hook for resizing windows is less precise than
;; ;; `doom-switch-window-hook'.
;; (remove-hook! ('window-configuration-change-hook 'org-now-hook
;; 'vterm-mode-hook) #'golden-ratio))
#+end_src

** ~magit-pretty-graph~ Ó∏ï :ARCHIVE:
/Prettier ~git log~ graph./
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
;; (package! magit-pretty-graph
;; :recipe (:host github
;; :repo "georgek/magit-pretty-graph"))
#+end_src

#+begin_src emacs-lisp
;; (use-package! magit-pretty-graph
;; :defer t
;; :after magit
;; :init
;; (setq magit-pg-command
;; (concat "git --no-pager log"
;; " --topo-order --decorate=full"
;; " --pretty=format:\"%H%x00%P%x00%an%x00%ar%x00%s%x00%d\""
;; " -n 2000")) ;; Increase the default 100 limit
;;
;; (map! :localleader
;; :map (magit-mode-map)
;; :desc "Magit pretty graph" "p" (cmd! (magit-pg-repo (magit-toplevel)))))
#+end_src

** ~just~ Ó∏ï ¬∑ Just do it :ARCHIVE:
/Like Makefile, but easier to grasp./
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
;; (package! just-mode)
;; (package! justl)
#+end_src

#+begin_src emacs-lisp
;; (use-package! justl
;; :defer t)
;;
;; (defun daf/consult-just ()
;; "Prompt a list of just recipes from the project. Run the selected candidate."
;; (interactive)
;; (let (recipes)
;; (setq recipes (justl--get-recipies-with-desc (justl--find-justfiles (projectile-project-root))))
;; (justl--exec justl-executable (list (completing-read "Choose an action: " recipes)))))
#+end_src

** ~multi-vterm~ Ó∏ï :ARCHIVE:
/Manage multiple instances of ~vterm~./
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
;; (package! multi-vterm
;; :recipe (:host github :repo "gagbo/multi-vterm" :branch "display_buffer"))
#+end_src

#+begin_src emacs-lisp
;; (use-package! multi-vterm
;; :defer t
;; :custom
;; ;; (multi-vterm-buffer-name "Terminal")
;; (multi-vterm-dedicated-buffer-name "dedicated vterminal")
;; (multi-vterm-dedicated-window-side 'bottom)
;;
;; :config
;; (set-popup-rules!
;; '(("^\\*vterm.*"
;; :slot 1 :vslot -2 :actions (+popup-display-buffer-stacked-side-window-fn) :side bottom :width 0.5 :height 0.55 :quit 'other :ttl nil)
;; ("^\\*dedicated vterminal.*"
;; :slot 2 :vslot -2 :actions (+popup-display-buffer-stacked-side-window-fn) :side bottom :width 0.5 :height 0.55 :quit 'other :ttl nil)))
;;
;; (evil-define-key 'normal vterm-mode-map (kbd "C-d") #'vterm--self-insert)
;; (evil-define-key 'normal vterm-mode-map (kbd ";c")  #'multi-vterm-project)
;; (evil-define-key 'normal vterm-mode-map (kbd ";n")  #'multi-vterm-next)
;; (evil-define-key 'normal vterm-mode-map (kbd ";p")  #'multi-vterm-prev)
;; (evil-define-key 'normal vterm-mode-map (kbd ";r")  #'multi-vterm-rename-buffer)
;; (evil-define-key 'normal vterm-mode-map (kbd ";;")  #'multi-vterm-dedicated-select)
;;
;; :init
;; (map! :leader
;; (:prefix ("o" . "open")
;; :desc "Dedicated terminal"      "t" #'multi-vterm-dedicated-toggle
;; :desc "Dedicated terminal here" "T" #'multi-vterm-project))
;;
;; (map! (:map vterm-mode-map
;; :localleader
;; :desc "Create"   "c" #'multi-vterm-project
;; :desc "Rename"   "r" #'multi-vterm-rename-buffer
;; :desc "Select"   "," #'multi-vterm-dedicated-select
;; :desc "Previous" "p" #'multi-vterm-prev
;; :desc "Next"     "n" #'multi-vterm-next)))
#+end_src

** ~combobulate~ Ó∏ï :ARCHIVE:
/Structured Editing and Navigation in Emacs with Tree-Sitter/
*** Configuration & Mapping

#+begin_src emacs-lisp :tangle packages.el
;; (package! combobulate) ;; https://github.com/mickeynp/combobulate
#+end_src

* Level 6: Central Processing ¬∑ /Lang stuff/

TODO: switch to ~novlang.el~ for *everything*.

** Plain text
*** Configuration

#+begin_quote
    Ispell is nice, let‚Äôs have it in text, markdown, and GFM.

‚ÄïTecosaur
#+end_quote

Let's add a couple pair of words to rotate.

#+begin_src emacs-lisp
(grugru-define-multiple
  (word "yes" "no")
  (word "true" "false")
  (word "left" "right"))
#+end_src

** Nix
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(unpin! nix-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! lsp-nix
  :after lsp-mode
  :demand t

  :custom
  (lsp-nix-nil-formatter ["nixfmt"]))

(use-package! nix-mode
  :hook (nix-mode . lsp-deferred)
  :hook (nix-mode . rainbow-delimiters-mode))
#+end_src

Let's add ¬´ /enabled/ ¬ª and ¬´ /disabled/ ¬ª to ~grugru~.

#+begin_src emacs-lisp
(grugru-define-global 'symbol '("enabled" "disabled"))
#+end_src

-----

* Level 7: Computer Station ¬∑ /Basically cheats and walk-through to survive Doom/

/The ~Doom~ world is massive, it can be daunting to remember every combo move,
secret passage and so on. I can't keep up. So I'll try to write a /cheat sheet or/
/some sort of wiki in this level./

** Mark ¬∑ It's like Nightcrawler in an editor
*** Mapping

|--------------------------------------+--------+---------|
| _Description_                          | _Scope_  | _Mapping_ |
|--------------------------------------+--------+---------|
| Create a ~mark~ bound to a register    | ~:nv~    | ~m [a-Z]~ |
| Jump to a ~mark~ bound to a register   | ~:nv~    | ~' [a-Z]~ |
| Show all ~marks~ in a completion menu: | leader | ~SPC s r~ |
|--------------------------------------+--------+---------|
** TODO ~occur~ replace in project
** Keybindings ¬∑ They're useful, brain; why do you forget them?

|---------+-------------------------------+---------|
| _Scope_   | _Description_                   | _Mapping_ |
|---------+-------------------------------+---------|
| ~vertico~ | Preview the current candidate | =C-SPC=   |
|         |                               |         |
|---------+-------------------------------+---------|
-----

* Level 9: Military Base ¬∑ /Secret experiments/

/We go straight to level 9, skipping level 8 altogether./

/Welcome to the *Military Base* where we conduct experimentation with unstable/
/elisp code. Then, when we are satisfied with the potency of the experiment, it
will be moved to the relevant level./

** evil mark
*** persist mark
#+BEGIN_SRC emacs-lisp
(after! savehist
  (add-to-list 'savehist-additional-variables 'evil-markers-alist)
  (add-hook! 'savehist-save-hook
    (kill-local-variable 'evil-markers-alist)
    (dolist (entry evil-markers-alist)
      (when (markerp (cdr entry))
        (setcdr entry (cons (file-truename (buffer-file-name (marker-buffer (cdr entry))))
                            (marker-position (cdr entry)))))))
  (add-hook! 'savehist-mode-hook
    (setq-default evil-markers-alist evil-markers-alist)
    (kill-local-variable 'evil-markers-alist)
    (make-local-variable 'evil-markers-alist)))
#+end_src

**** ~evil-fringe-mark~
/Display evil-mode markers in the Emacs fringe/
***** Configuration
#+begin_src emacs-lisp :tangle packages.el
(package! evil-fringe-mark) ;; https://github.com/Andrew-William-Smith/evil-fringe-mark
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! evil-fringe-mark
  :defer t
  :after evil
  :config
  ;; Use right fringe
  (setq-default right-fringe-width 16)
  (setq-default evil-fringe-mark-side 'right-fringe))
:init
(global-evil-fringe-mark-mode 1)
#+END_SRC

** ~meow~ ¬∑ Ó∏ï :ARCHIVE:
/Yet another modal editing on Emacs / Áå´ÊÄÅÁºñËæë/
*** Configuration
#+begin_src emacs-lisp :tangle packages.el
(package! meow
  :disable t) ;; https://github.com/meow-edit/meow
#+end_src

#+begin_src emacs-lisp
(use-package! meow)


(defconst meow-cheatsheet-layout-bepo
  '((<TLDE> "$"	"#")
    (<AE01> "\"" "1")
    (<AE02> "¬´"	"2")
    (<AE03> "¬ª"	"3")
    (<AE04> "("	"4")
    (<AE05> ")"	"5")
    (<AE06> "@"	"6")
    (<AE07> "+"	"7")
    (<AE08> "-"	"8")
    (<AE09> "/"	"9")
    (<AE10> "*"	"0")
    (<AE11> "="	"¬∞")
    (<AE12> "%"	"`")
    (<AD01> "b"	"B")
    (<AD02> "√©"	"√â")
    (<AD03> "p"	"P")
    (<AD04> "o"	"O")
    (<AD05> "√®"	"√à")
    (<AD06> "^"	"!")
    (<AD07> "v"	"V")
    (<AD08> "d"	"D")
    (<AD09> "l"	"L")
    (<AD10> "j"	"J")
    (<AD11> "z"	"Z")
    (<AD12> "w"	"W")
    (<AC01> "a"	"A")
    (<AC02> "u"	"U")
    (<AC03> "i"	"I")
    (<AC04> "e"	"E")
    (<AC05> ","	";")
    (<AC06> "c"	"C")
    (<AC07> "t"	"T")
    (<AC08> "s"	"S")
    (<AC09> "r"	"R")
    (<AC10> "n"	"N")
    (<AC11> "m"	"M")
    (<AB01> "√†"	"√Ä")
    (<AB02> "y"	"Y")
    (<AB03> "x"	"X")
    (<AB04> "."	":")
    (<AB05> "k"	"K")
    (<AB06> "'"	"?")
    (<AB07> "q"	"Q")
    (<AB08> "g"	"G")
    (<AB09> "h"	"H")
    (<AB10> "f"	"F")
    (<BKSL> "√ß" "√á")
    (<LSGT> "√™" "√ä")))


(defun daf/meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-bepo)
  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '("," . meow-reverse)
   '("(" . meow-inner-of-thing)
   '(")" . meow-bounds-of-thing)
   '("¬´" . meow-beginning-of-thing)
   '("¬ª" . meow-end-of-thing)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("l" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("c" . meow-left)
   '("C" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("t" . meow-next)
   '("T" . meow-next-expand)
   '("s" . meow-prev)
   '("S" . meow-prev-expand)
   '("r" . meow-right)
   '("R" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-yank)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("j" . meow-replace)
   '("J" . meow-swap-grab)
   '("k" . meow-kill)
   '("h" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("." . repeat)
   '("<escape>" . ignore)))
;; (daf/meow-setup)
;;(meow-global-mode 1)
#+end_src

** ~org-wild-notifier~
/Alert notifications for org-agenda/
*** Configuration
#+begin_src emacs-lisp :tangle packages.el
(package! org-wild-notifier) ;; https://github.com/akhramov/org-wild-notifier.el
#+end_src

#+begin_src emacs-lisp
(use-package! org-wild-notifier
  :hook (org-load . org-wild-notifier-mode)
  :config
  (setq alert-default-style 'notification))
#+end_src

** ~systemd~
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! systemd) ;; https://github.com/holomorph/systemd-mode
#+end_src

** ~nano-modeline~
*** Configuration

#+begin_src emacs-lisp :tangle packages.el
(package! nano-modeline)
#+end_src

#+begin_src emacs-lisp
(use-package! nano-modeline
  :custom
  (fringes-outside-margins t))

(add-hook 'prog-mode-hook            #'nano-modeline-prog-mode)
(add-hook 'text-mode-hook            #'nano-modeline-text-mode)
(add-hook 'org-mode-hook             #'nano-modeline-org-mode)
(add-hook 'pdf-view-mode-hook        #'nano-modeline-pdf-mode)
(add-hook 'mu4e-headers-mode-hook    #'nano-modeline-mu4e-headers-mode)
(add-hook 'mu4e-view-mode-hook       #'nano-modeline-mu4e-message-mode)
(add-hook 'elfeed-show-mode-hook     #'nano-modeline-elfeed-entry-mode)
(add-hook 'elfeed-search-mode-hook   #'nano-modeline-elfeed-search-mode)
(add-hook 'term-mode-hook            #'nano-modeline-term-mode)
(add-hook 'vterm-mode-hook           #'daf/nano-modeline-vterm-mode)
(add-hook 'xwidget-webkit-mode-hook  #'nano-modeline-xwidget-mode)
(add-hook 'messages-buffer-mode-hook #'nano-modeline-message-mode)
(add-hook 'org-capture-mode-hook     #'nano-modeline-org-capture-mode)
(add-hook 'org-agenda-mode-hook      #'nano-modeline-org-agenda-mode)

(add-hook 'doom-load-theme-hook      #'daf/set-nano-modeline-face)

(defun daf/set-nano-modeline-face ()
  "Inherit faces from either mode-line or header-line"
  (let ((nano-modeline-face
         (if (eq (face-attribute 'header-line :background) 'unspecified)
             'mode-line
           'header-line)))
    (custom-set-faces!
      `(nano-modeline-active
        :foreground ,(face-attribute 'default :foreground)
        :background ,(face-attribute nano-modeline-face :background)
        :box nil)
      '(nano-modeline-inactive
        :inherit 'mode-line-inactive
        :box nil))))

(defun daf/nano-modeline-vterm-mode ()
  "Nano line for term mode"
  (funcall nano-modeline-position
           '((nano-modeline-buffer-status ">_") " ")
           '((nano-modeline-default-directory) " "
             (nano-modeline-window-dedicated))))
#+end_src

** Disabling ~helm~ stuff

#+begin_src emacs-lisp :tangle packages.el
(package! helm :disable t)
(package! helm-org :disable t)
#+end_src

** Ensure blank lines between headings and before contents

#+begin_src emacs-lisp
;;;###autoload
(defun unpackaged/org-fix-blank-lines (&optional prefix)
  "Ensure that blank lines exist between headings and between headings and their contents.
With prefix, operate on whole buffer. Ensures that blank lines
exist after each headings's drawers."
  (interactive "P")
  (org-map-entries (lambda ()
                     (org-with-wide-buffer
                      ;; `org-map-entries' narrows the buffer, which prevents us from seeing
                      ;; newlines before the current heading, so we do this part widened.
                      (while (not (looking-back "\n\n" nil))
                        ;; Insert blank lines before heading.
                        (insert "\n")))
                     (let ((end (org-entry-end-position)))
                       ;; Insert blank lines before entry content
                       (forward-line)
                       (while (and (org-at-planning-p)
                                   (< (point) (point-max)))
                         ;; Skip planning lines
                         (forward-line))
                       (while (re-search-forward org-drawer-regexp end t)
                         ;; Skip drawers. You might think that `org-at-drawer-p' would suffice, but
                         ;; for some reason it doesn't work correctly when operating on hidden text.
                         ;; This works, taken from `org-agenda-get-some-entry-text'.
                         (re-search-forward "^[ \t]*:END:.*\n?" end t)
                         (goto-char (match-end 0)))
                       (unless (or (= (point) (point-max))
                                   (org-at-heading-p)
                                   (looking-at-p "\n"))
                         (insert "\n"))))
                   t (if prefix
                         nil
                       'tree)))
#+end_src
** hl-todo

#+begin_src emacs-lisp
(after! hl-todo
  (add-to-list 'hl-todo-keyword-faces '("NOCOMMIT" error bold)))
#+end_src

* Level ‚Ö©: Sewers ¬∑ /It never ends‚Ä¶/

¬´ /Tinkering/ ¬ª Emacs is a never ending story. I'll always have stuff to tweak,
new packages to try out, bug or unsatisfactory workflow‚Ä¶ I'll try to remember to
reference all that here.

** Known Issues [4/7]

- [X] ~doom-modeline~ isn't happy about font profile switching
- [X] (layout +bepo) isn't working
- [X] (layout +bepo) isn't working, take 2
- [X] ~company~ glitches with variable fonts (maybe?)
- [ ] emojis and symbols are giving me trouble
  - [ ] can't disable specific symbols
- [ ] ~flycheck~ is activated where it shouldn't
  specifically the ~javascript-eslint~ checker, is activated in buffer (not
  attached to a file) and complains about invalid syntax where it shouldn't. For
  instance when merging javascript/typescript files in ediff, syntax is invalid,
  because of the diff's block, this is expected.
- [ ] ~evil-surround~ needs to be reloaded for keybindings to work.

** Todos [5/6]
- [[id:2c81f9a0-5ab2-4c4f-bbbe-d40d1976fb49][Emacs Configuration [3/22]‚Äã]]
- [X] migrate elogcat stuff for android
- [X] finish font setup
  - [X] Iosevka Comfy Wide Duo isn't available on my system
  - [X] setup Overpass font (to try it out)
- [X] add ~nov.el~ maybe a private module?
- [X] add ~verb.el~ maybe a private module?
- [X] setup ~burly.el~
  - [X] bookmarks not persisted
- [ ] try to make a custom function to prompt ~rotate:layout~
  maybe use ~consult--read~ for previewing result?

** Check it out!
- [ ] guess-language.el
- [ ] tempel
- [ ] activities.el

  -----
